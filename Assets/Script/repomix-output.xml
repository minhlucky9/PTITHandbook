This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
Core.meta
Core/AnimatorManager.cs
Core/AnimatorManager.cs.meta
Core/CharacterManager.cs
Core/CharacterManager.cs.meta
Core/CharacterStats.cs
Core/CharacterStats.cs.meta
Core/DataObject.meta
Core/DataObject/Quest.cs
Core/DataObject/Quest.cs.meta
Core/DataObject/QuestInfoSO.cs
Core/DataObject/QuestInfoSO.cs.meta
Core/DSDialogAdapter.cs
Core/DSDialogAdapter.cs.meta
Core/Interactable.cs
Core/Interactable.cs.meta
Core/ScriptableObject.meta
Core/ScriptableObject/Functional.meta
Core/ScriptableObject/Functional/FunctionalWindowDataSO.cs
Core/ScriptableObject/Functional/FunctionalWindowDataSO.cs.meta
Core/ScriptableObject/Functional/ShopWindowDataSO.cs
Core/ScriptableObject/Functional/ShopWindowDataSO.cs.meta
Core/ScriptableObject/Item.meta
Core/ScriptableObject/Item/ItemSO.cs
Core/ScriptableObject/Item/ItemSO.cs.meta
Core/ScriptableObject/Item/QuestItemSO.cs
Core/ScriptableObject/Item/QuestItemSO.cs.meta
Core/ScriptableObject/Item/UsableItemSO.cs
Core/ScriptableObject/Item/UsableItemSO.cs.meta
Core/ScriptableObject/Minigame.meta
Core/ScriptableObject/Minigame/ChangeSceneEvent.cs
Core/ScriptableObject/Minigame/ChangeSceneEvent.cs.meta
Core/ScriptableObject/Minigame/LootEventSO.cs
Core/ScriptableObject/Minigame/LootEventSO.cs.meta
Core/ScriptableObject/Minigame/MinigameDataSO.cs
Core/ScriptableObject/Minigame/MinigameDataSO.cs.meta
Core/ScriptableObject/Minigame/QuizConservationSO.cs
Core/ScriptableObject/Minigame/QuizConservationSO.cs.meta
Core/ScriptableObject/New NPC Conservation SO.asset
Core/ScriptableObject/New NPC Conservation SO.asset.meta
Core/ScriptableObject/NPCConservationSO.cs
Core/ScriptableObject/NPCConservationSO.cs.meta
Core/ScriptableObject/NPCInfoSO.cs
Core/ScriptableObject/NPCInfoSO.cs.meta
DialogueSystem.meta
DialogueSystem/CollectionUltility.cs
DialogueSystem/CollectionUltility.cs.meta
DialogueSystem/Data.meta
DialogueSystem/Data/Error.meta
DialogueSystem/Data/Error/DSErrorData.cs
DialogueSystem/Data/Error/DSErrorData.cs.meta
DialogueSystem/Data/Error/DSGroupErrorData.cs
DialogueSystem/Data/Error/DSGroupErrorData.cs.meta
DialogueSystem/Data/Error/DSNodeErrorData.cs
DialogueSystem/Data/Error/DSNodeErrorData.cs.meta
DialogueSystem/Data/Save.meta
DialogueSystem/Data/Save/DSChoiceSaveData.cs
DialogueSystem/Data/Save/DSChoiceSaveData.cs.meta
DialogueSystem/Data/Save/DSGraphSaveDataSO.cs
DialogueSystem/Data/Save/DSGraphSaveDataSO.cs.meta
DialogueSystem/Data/Save/DSGroupSaveData.cs
DialogueSystem/Data/Save/DSGroupSaveData.cs.meta
DialogueSystem/Data/Save/DSNodeSaveData.cs
DialogueSystem/Data/Save/DSNodeSaveData.cs.meta
DialogueSystem/Elements.meta
DialogueSystem/Elements/DSGroup.cs
DialogueSystem/Elements/DSGroup.cs.meta
DialogueSystem/Elements/DSMultipleChoiceNode.cs
DialogueSystem/Elements/DSMultipleChoiceNode.cs.meta
DialogueSystem/Elements/DSNode.cs
DialogueSystem/Elements/DSNode.cs.meta
DialogueSystem/Elements/DSSingleChoiceNode.cs
DialogueSystem/Elements/DSSingleChoiceNode.cs.meta
DialogueSystem/Graphs.meta
DialogueSystem/Graphs/cGraph.asset
DialogueSystem/Graphs/cGraph.asset.meta
DialogueSystem/Graphs/test1Graph.asset
DialogueSystem/Graphs/test1Graph.asset.meta
DialogueSystem/Graphs/testGraph.asset
DialogueSystem/Graphs/testGraph.asset.meta
DialogueSystem/Graphs/zGraph.asset
DialogueSystem/Graphs/zGraph.asset.meta
DialogueSystem/Inspectors.meta
DialogueSystem/Inspectors/DSInspector.cs
DialogueSystem/Inspectors/DSInspector.cs.meta
DialogueSystem/SerializableDictionary.cs
DialogueSystem/SerializableDictionary.cs.meta
DialogueSystem/TextUtility.cs
DialogueSystem/TextUtility.cs.meta
DialogueSystem/Ultilities.meta
DialogueSystem/Ultilities/DSElementsUltilities.cs
DialogueSystem/Ultilities/DSElementsUltilities.cs.meta
DialogueSystem/Ultilities/DSInspectorUltility.cs
DialogueSystem/Ultilities/DSInspectorUltility.cs.meta
DialogueSystem/Ultilities/DSIOUltility.cs
DialogueSystem/Ultilities/DSIOUltility.cs.meta
DialogueSystem/Ultilities/DSStylesUltilities.cs
DialogueSystem/Ultilities/DSStylesUltilities.cs.meta
DialogueSystem/Windows.meta
DialogueSystem/Windows/DSEditorWindow.cs
DialogueSystem/Windows/DSEditorWindow.cs.meta
DialogueSystem/Windows/DSGraphView.cs
DialogueSystem/Windows/DSGraphView.cs.meta
DialogueSystem/Windows/DSSearchWindow.cs
DialogueSystem/Windows/DSSearchWindow.cs.meta
DontDestroyOnLoad.cs
DontDestroyOnLoad.cs.meta
EnemyManager.meta
EnemyManager/ResetAnimatorParameter.cs
EnemyManager/ResetAnimatorParameter.cs.meta
GameManager.meta
GameManager/AudioManager.cs
GameManager/AudioManager.cs.meta
GameManager/GameUI.meta
GameManager/GameUI/ConservationManager.cs
GameManager/GameUI/ConservationManager.cs.meta
GameManager/GameUI/Inventory.meta
GameManager/GameUI/Inventory/InventoryItemUI.cs
GameManager/GameUI/Inventory/InventoryItemUI.cs.meta
GameManager/GameUI/Inventory/InventoryUIManager.cs
GameManager/GameUI/Inventory/InventoryUIManager.cs.meta
GameManager/GameUI/Shop.meta
GameManager/GameUI/Shop/ShopProductUI.cs
GameManager/GameUI/Shop/ShopProductUI.cs.meta
GameManager/GameUI/Shop/ShopWindowManager.cs
GameManager/GameUI/Shop/ShopWindowManager.cs.meta
GameManager/GameUI/UIManager.cs
GameManager/GameUI/UIManager.cs.meta
GameManager/Minigame.meta
GameManager/Minigame/CollectQuestManager.cs
GameManager/Minigame/CollectQuestManager.cs.meta
GameManager/Minigame/MazeSceneManager.cs
GameManager/Minigame/MazeSceneManager.cs.meta
GameManager/Minigame/QuizManager.cs
GameManager/Minigame/QuizManager.cs.meta
GameManager/QuestManager.cs
GameManager/QuestManager.cs.meta
GameManager/SubSceneGameManager.cs
GameManager/SubSceneGameManager.cs.meta
InteractableObject.meta
InteractableObject/Item.meta
InteractableObject/Item/CoinLootInteraction.cs
InteractableObject/Item/CoinLootInteraction.cs.meta
InteractableObject/Item/LootInteraction.cs
InteractableObject/Item/LootInteraction.cs.meta
InteractableObject/NPC.meta
InteractableObject/NPC/NPCController.cs
InteractableObject/NPC/NPCController.cs.meta
InteractableObject/NPC/TalkInteraction.cs
InteractableObject/NPC/TalkInteraction.cs.meta
PlayerManager.meta
PlayerManager/InputController.meta
PlayerManager/InputController/InputHandle.cs
PlayerManager/InputController/InputHandle.cs.meta
PlayerManager/InputController/MouseManager.cs
PlayerManager/InputController/MouseManager.cs.meta
PlayerManager/InputController/PlayerControls.cs
PlayerManager/InputController/PlayerControls.cs.meta
PlayerManager/InputController/PlayerControls.inputactions
PlayerManager/InputController/PlayerControls.inputactions.meta
PlayerManager/PlayerAnimatorHandle.cs
PlayerManager/PlayerAnimatorHandle.cs.meta
PlayerManager/PlayerCombat.meta
PlayerManager/PlayerCombat/DamagePlayer.cs
PlayerManager/PlayerCombat/DamagePlayer.cs.meta
PlayerManager/PlayerCombat/PlayerBuff.meta
PlayerManager/PlayerCombat/PlayerBuff/BuffEffect.cs
PlayerManager/PlayerCombat/PlayerBuff/BuffEffect.cs.meta
PlayerManager/PlayerCombat/PlayerBuff/PlayerBuffManager.cs
PlayerManager/PlayerCombat/PlayerBuff/PlayerBuffManager.cs.meta
PlayerManager/PlayerInventory.meta
PlayerManager/PlayerInventory/PlayerInventory.cs
PlayerManager/PlayerInventory/PlayerInventory.cs.meta
PlayerManager/PlayerManager.cs
PlayerManager/PlayerManager.cs.meta
PlayerManager/PlayerMovement.meta
PlayerManager/PlayerMovement/CameraHandle.cs
PlayerManager/PlayerMovement/CameraHandle.cs.meta
PlayerManager/PlayerMovement/PlayerLocomotion.cs
PlayerManager/PlayerMovement/PlayerLocomotion.cs.meta
PlayerManager/PlayerStats.meta
PlayerManager/PlayerStats/PlayerStats.cs
PlayerManager/PlayerStats/PlayerStats.cs.meta
PlayerManager/PlayerStats/PlayerUI.meta
PlayerManager/PlayerStats/PlayerUI/HealthBar.cs
PlayerManager/PlayerStats/PlayerUI/HealthBar.cs.meta
PlayerManager/PlayerStats/PlayerUI/StaminaBar.cs
PlayerManager/PlayerStats/PlayerUI/StaminaBar.cs.meta
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="Core.meta">
fileFormatVersion: 2
guid: b4d70ee396c7a5b47aa51eba88a36883
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="Core/AnimatorManager.cs">
using PlayerController;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Core
{
    public class AnimatorManager : MonoBehaviour
    {
        public Animator anim;
        public bool canRotate;

        public void PlayTargetAnimation(string targetAnim, bool isInteracting, float delay = 0f)
        {
            anim.applyRootMotion = isInteracting;
            anim.SetBool("canRotate", false);
            anim.SetBool("isInteracting", isInteracting);

            PlayerManager.instance.isInteracting = isInteracting;

            StartCoroutine(RunAnimation(targetAnim, delay));
        }

        public virtual void TakeCriticalDamageAnimationEvent()
        {

        }

        private IEnumerator RunAnimation(string targetAnim, float delay)
        {
            yield return new WaitForSeconds(delay);
            anim.CrossFade(targetAnim, 0.2f);

            yield return null;
        }
    }
}
</file>

<file path="Core/AnimatorManager.cs.meta">
fileFormatVersion: 2
guid: f78edfd5512ee654c936f409396721f3
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="Core/CharacterManager.cs">
using PlayerStatsController;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Core
{
    public class CharacterManager : MonoBehaviour
    {
        [Header("Lock On Transform")]
        public Transform lockOnTransform;

        [Header("Combat Colliders")]
        public BoxCollider backStabBoxCollider;

        public int pendingCriticalDamage;
    }
}
</file>

<file path="Core/CharacterManager.cs.meta">
fileFormatVersion: 2
guid: addc51850bf29144d9d5181b75fcebcb
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="Core/CharacterStats.cs">
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Core
{
    public class CharacterStats : MonoBehaviour
    {
        public int characterLevel;
        public int characterExp = 0;

        public int healthLevel = 10;
        public int maxHealth;
        public int currentHealth;

        [Header("Movement Stats")]
        public int staminaLevel = 10;
        public float maxStamina;
        public float currentStamina;
        public float speedMultiplier = 1;
        public bool isLockStamina = false;


        public bool isDead;

        public void ExpGain(int amount)
        {
            characterExp += amount;
            if(characterExp >= 100)
            {
                characterLevel++;
                characterExp = characterExp % 100;
            }
        }
    }

}
</file>

<file path="Core/CharacterStats.cs.meta">
fileFormatVersion: 2
guid: 956b3ff3de43777408fe63b50ba0c8f6
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="Core/DataObject.meta">
fileFormatVersion: 2
guid: 6bb1b47611335604590573df5a6c9693
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="Core/DataObject/Quest.cs">
using Interaction;
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public enum QuestState
{
    REQUIREMENTS_NOT_MET,
    CAN_START,
    IN_PROGRESS,
    FINISHED
}

public class Quest
{
    // static info
    public QuestInfoSO info;

    // state info
    public QuestState state;
    public int currentQuestStepIndex;
    public QuestStepState[] questStepStates;

    public Action OnQuestFinish;

    public bool isCurrentStepExists() => (currentQuestStepIndex < info.questSteps.Count);

    public Quest(QuestInfoSO questInfo)
    {
        info = questInfo;
        state = QuestState.REQUIREMENTS_NOT_MET;
        currentQuestStepIndex = 0;
        questStepStates = new QuestStepState[info.questSteps.Count];
        for (int i = 0; i < questStepStates.Length; i++)
        {
            questStepStates[i] = new QuestStepState();
        }
    }

    public Quest(QuestInfoSO questInfo, QuestState questState, int currentQuestStepIndex, QuestStepState[] questStepStates)
    {
        this.info = questInfo;
        this.state = questState;
        this.currentQuestStepIndex = currentQuestStepIndex;
        this.questStepStates = questStepStates;

        // if the quest step states and prefabs are different lengths,
        // something has changed during development and the saved data is out of sync.
        if (this.questStepStates.Length != this.info.questSteps.Count)
        {
            Debug.LogWarning("Quest Step Prefabs and Quest Step States are "
                + "of different lengths. This indicates something changed "
                + "with the QuestInfo and the saved data is now out of sync. "
                + "Reset your data - as this might cause issues. QuestId: " + this.info.id);
        }
    }

    public bool TryNextStep()
    {
        currentQuestStepIndex++;
        //check if there is step behind
        if (isCurrentStepExists())
        {
            ChangeQuestState(QuestState.IN_PROGRESS);
            return true;
        } 
        else
        {
            OnQuestFinish?.Invoke();
            ChangeQuestState(QuestState.FINISHED);
            return false;
        }
    }

    public void ChangeQuestState(QuestState state)
    {
        this.state = state;
    }

}

[System.Serializable]
public class QuestData
{
    public QuestState state;
    public int questStepIndex;
    public QuestStepState[] questStepStates;

    public QuestData(QuestState state, int questStepIndex, QuestStepState[] questStepStates)
    {
        this.state = state;
        this.questStepIndex = questStepIndex;
        this.questStepStates = questStepStates;
    }
}

[System.Serializable]
public class QuestStepState
{
    public string state;
    public string status;


    public QuestStepState(string state, string status)
    {
        this.state = state;
        this.status = status;
    }

    public QuestStepState()
    {
        this.state = "";
        this.status = "";
    }
}
</file>

<file path="Core/DataObject/Quest.cs.meta">
fileFormatVersion: 2
guid: a667240c5055e91489c12339269b0887
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="Core/DataObject/QuestInfoSO.cs">
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Interaction
{
    [CreateAssetMenu(menuName = "Scriptable Objects/Quest/Quest Info")]
    public class QuestInfoSO : ScriptableObject
    {
        [field: SerializeField] public string id { get; private set; }

        [Header("General")]
        public string displayName;

        [Header("Requirements")]
        public int levelRequirement;
        public QuestInfoSO[] questPrerequisites;

        [Header("Steps")]
        public List<QuestStep> questSteps;

        [Header("Rewards")]
        public int goldReward;
        public int experienceReward;
        public List<ItemReward> itemRewards;

        // ensure the id is always the name of the Scriptable Object asset
        private void OnValidate()
        {
#if UNITY_EDITOR
            id = this.name;
#endif
        }
    }
    [System.Serializable]
    public class QuestStep
    {
        public string stepId;
        public StepMissionType missionType;
        [TextArea(2,4)]
        public string stepName;
        [TextArea(4,8)]
        public string stepDescription;
        public string npcId;
        public NPCState npcStatus;
        public NPCConservationSO conservation;
        public string nextStep;
    }

    [System.Serializable]
    public class ItemReward
    {
        public ItemSO item;
        public int quantity;
    }

    public enum StepMissionType
    {
        TALKING,
        MINIGAME
    }
}
</file>

<file path="Core/DataObject/QuestInfoSO.cs.meta">
fileFormatVersion: 2
guid: d6b8fb76b99894d48bb526e5bb6840c2
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="Core/DSDialogAdapter.cs">
using UnityEngine;
using DS.ScriptableObjects; // For DSDialogueSO, DSDialogueContainerSO
using System.Collections.Generic;
using System.Linq;
using Interaction; // For DialogConservation, DialogResponse, etc.

public class DSDialogueAdapter : MonoBehaviour
{
   

    // map nodeName -> DSDialogueSO (for quick lookup)
    private Dictionary<string, DSDialogueSO> nodeLookup = new Dictionary<string, DSDialogueSO>();

    public void Initialize(DSDialogueContainerSO container)
    {
        nodeLookup.Clear();
        Debug.Log($"Initializing dialogue container with {container.DialogueGroups.Count} groups and {container.UngroupedDialogues.Count} ungrouped dialogues");

        // load group dialogues
        foreach (var kv in container.DialogueGroups)
        {
            Debug.Log($"Processing group: {kv.Key.name} with {kv.Value.Count} dialogues");
            foreach (var d in kv.Value)
            {
                nodeLookup[d.DialogueName] = d;
                Debug.Log($"Added grouped dialogue: '{d.DialogueName}' with {d.Choices?.Count ?? 0} choices");
                if (d.Choices != null)
                {
                    foreach (var choice in d.Choices)
                    {
                        Debug.Log($"  Choice: '{choice.Text}' -> Next: {(choice.NextDialogue != null ? choice.NextDialogue.DialogueName : "null")}");
                        if (choice.NextDialogue != null)
                        {
                            Debug.Log($"    Next dialogue exists: {choice.NextDialogue.DialogueName}");
                        }
                    }
                }
            }
        }
        // load ungrouped dialogues
        foreach (var d in container.UngroupedDialogues)
        {
            nodeLookup[d.DialogueName] = d;
            Debug.Log($"Added ungrouped dialogue: '{d.DialogueName}' with {d.Choices?.Count ?? 0} choices");
            if (d.Choices != null)
            {
                foreach (var choice in d.Choices)
                {
                    Debug.Log($"  Choice: '{choice.Text}' -> Next: {(choice.NextDialogue != null ? choice.NextDialogue.DialogueName : "null")}");
                    if (choice.NextDialogue != null)
                    {
                        Debug.Log($"    Next dialogue exists: {choice.NextDialogue.DialogueName}");
                    }
                }
            }
        }

        // Verify all next dialogues exist
        Debug.Log("Verifying next dialogue connections...");
        foreach (var node in nodeLookup.Values)
        {
            if (node.Choices != null)
            {
                foreach (var choice in node.Choices)
                {
                    if (choice.NextDialogue != null && !nodeLookup.ContainsKey(choice.NextDialogue.DialogueName))
                    {
                        Debug.LogError($"Invalid connection: Node '{node.DialogueName}' choice '{choice.Text}' points to non-existent node '{choice.NextDialogue.DialogueName}'");
                    }
                }
            }
        }
    }

    // Convert 1 DSDialogueSO -> 1 DialogConservation
    public DialogConservation ConvertDSDialogueToConservation(DSDialogueSO dsDialogue)
    {
        if (dsDialogue == null) return null;

        Debug.Log($"Converting dialogue: '{dsDialogue.DialogueName}' to conservation");
        DialogConservation cons = new DialogConservation();
        cons.dialogId = dsDialogue.DialogueName;
        cons.message = dsDialogue.Text;
        cons.possibleResponses = new List<DialogResponse>();

        if (dsDialogue.Choices != null)
        {
            Debug.Log($"Processing {dsDialogue.Choices.Count} choices for dialogue '{dsDialogue.DialogueName}'");
            foreach (var choice in dsDialogue.Choices)
            {
                var resp = new DialogResponse();
                resp.message = choice.Text;
                resp.executedFunction = dsDialogue.ExecutedFunction;
                
                // Log the choice and its next dialogue before setting nextDialogId
                Debug.Log($"Processing choice: '{choice.Text}'");
                Debug.Log($"  NextDialogue is {(choice.NextDialogue != null ? "not null" : "null")}");
                if (choice.NextDialogue != null)
                {
                    Debug.Log($"  NextDialogue name: '{choice.NextDialogue.DialogueName}'");
                    Debug.Log($"  NextDialogue exists in lookup: {nodeLookup.ContainsKey(choice.NextDialogue.DialogueName)}");
                }

                // nextDialogId = NextDialogue.DialogueName if not null
                resp.nextDialogId = choice.NextDialogue ? choice.NextDialogue.DialogueName : "";
                Debug.Log($"  Set nextDialogId to: '{resp.nextDialogId}'");
                
                cons.possibleResponses.Add(resp);
            }
        }
        return cons;
    }

    // Lấy DSDialogueSO theo tên
    public DSDialogueSO GetNodeByName(string nodeName)
    {
        Debug.Log($"Looking for node with name: '{nodeName}'");
        Debug.Log($"Current nodeLookup count: {nodeLookup.Count}");
        
        if (string.IsNullOrEmpty(nodeName))
        {
            Debug.LogError("Attempted to look up node with null or empty name");
            return null;
        }

        if (nodeLookup.TryGetValue(nodeName, out var node))
        {
            Debug.Log($"Found node: '{node.DialogueName}'");
            Debug.Log($"Node details - Choices count: {node.Choices?.Count ?? 0}");
            if (node.Choices != null)
            {
                foreach (var choice in node.Choices)
                {
                    Debug.Log($"  Choice: '{choice.Text}' -> Next: {(choice.NextDialogue != null ? choice.NextDialogue.DialogueName : "null")}");
                }
            }
            return node;
        }
        else
        {
            Debug.LogError($"Node '{nodeName}' not found in lookup dictionary");
            Debug.Log("Available nodes in lookup:");
            foreach (var name in nodeLookup.Keys)
            {
                Debug.Log($"- '{name}'");
            }
            return null;
        }
    }

    // Debug methods
    public int GetNodeLookupCount()
    {
        return nodeLookup.Count;
    }

    public void LogNodeNames()
    {
        Debug.Log("Available node names:");
        foreach (var name in nodeLookup.Keys)
        {
            Debug.Log($"- '{name}'");
        }
    }
}
</file>

<file path="Core/DSDialogAdapter.cs.meta">
fileFormatVersion: 2
guid: c44108139d4953b448066330e716463a
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="Core/Interactable.cs">
using PlayerController;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Core
{
    public class Interactable : MonoBehaviour
    {
        public float radius = 0.6f;
        public string interactableText;
        public bool isInteracting = false;


        #region OnDrawGizmosSelected() là gì
        /*--------------------------------------------------------------------------------------------------------------------------------------------*/

        /* OnDrawGizmosSelected() là một hàm đặc biệt trong Unity được gọi bởi Editor (trong Scene View) để vẽ gizmos chỉ khi GameObject đang được chọn (selected). */

        /* OnDrawGizmosSelected() chỉ có tác dụng trong Unity Editor và không hiển thị trong bản build của game, chỉ dùng cho debug, không ảnh hưởng đến gameplay */

        /* OnDrawGizmosSelected() ở dưới giúp chúng vẽ vùng tròn màu xanh dương xung quanh nhân vật để thể hiện khoảng không gian có thể tương tác với NPC */

        /*--------------------------------------------------------------------------------------------------------------------------------------------*/

        #endregion

        private void OnDrawGizmosSelected()
        {
            Gizmos.color = Color.blue;
            Gizmos.DrawSphere(transform.position, radius);
        }

        public virtual void Interact()
        {
      
        }

        public virtual void StopInteract()
        {
    
        }
    }
}
</file>

<file path="Core/Interactable.cs.meta">
fileFormatVersion: 2
guid: fc8941469a26eb242953117c41539874
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="Core/ScriptableObject.meta">
fileFormatVersion: 2
guid: 32b064de6e1463e4b813bdcbe541c33f
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="Core/ScriptableObject/Functional.meta">
fileFormatVersion: 2
guid: a8b7da71621d79445a6e19038a127d34
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="Core/ScriptableObject/Functional/FunctionalWindowDataSO.cs">
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public enum FunctionType { Shop };

public class FunctionalWindowDataSO : ScriptableObject
{
    public string functionId;
    public FunctionType type;
    public string npcId;

    GameObject targetGameObject;

    public virtual void Init(GameObject target)
    {
        targetGameObject = target;
    }

    private void OnValidate()
    {
#if UNITY_EDITOR
        functionId = type.ToString() + "_" + npcId;
#endif
    }

}
</file>

<file path="Core/ScriptableObject/Functional/FunctionalWindowDataSO.cs.meta">
fileFormatVersion: 2
guid: c31e13df84a1bef44823fb13bc748b84
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="Core/ScriptableObject/Functional/ShopWindowDataSO.cs">
using Interaction;
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(menuName = "Scriptable Objects/Functional/Shop Data")]
public class ShopWindowDataSO : FunctionalWindowDataSO
{
    public List<ShopCategory> shopCategories;

    public override void Init(GameObject target)
    {
        base.Init(target);
        ShopWindowManager.instance.OpenWindow(this);
    }
}

[Serializable]
public class ShopCategory
{
    public string categoryName;
    public Sprite iconInShop;
    public List<ShopItem> shopItems;
}

[Serializable]
public struct ShopItem
{
    public ItemSO itemInfo;
    public int price;
    public string value;
    public Sprite valueIcon;

    public bool TryBuyItem()
    {
        return PlayerInventory.instance.TryBuyItem(price, itemInfo);
    }
}
</file>

<file path="Core/ScriptableObject/Functional/ShopWindowDataSO.cs.meta">
fileFormatVersion: 2
guid: 98c4af2c76fc3794b9bbbb79cf57f465
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="Core/ScriptableObject/Item.meta">
fileFormatVersion: 2
guid: af5330c47b294eb41a20c581004fd7dd
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="Core/ScriptableObject/Item/ItemSO.cs">
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Interaction
{
    public class ItemSO : ScriptableObject
    {
        public string itemId;
        public GameObject prefabs;
        public Sprite itemImage;
        public string itemName;
        [TextArea(2, 4)]
        public string itemDescription;
        public bool isStackable;
        public int maxStackSize;

        public virtual void UseItem() { }

        private void OnValidate()
        {
#if UNITY_EDITOR
            itemId = this.name;
#endif
        }
    }
}
</file>

<file path="Core/ScriptableObject/Item/ItemSO.cs.meta">
fileFormatVersion: 2
guid: 234e9072d67a3df47a86c16b7e30ae7f
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="Core/ScriptableObject/Item/QuestItemSO.cs">
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Interaction
{
    [CreateAssetMenu(menuName = "Scriptable Objects/Item/Quest Item")]
    public class QuestItemSO : ItemSO
    {
        
    }
}
</file>

<file path="Core/ScriptableObject/Item/QuestItemSO.cs.meta">
fileFormatVersion: 2
guid: 4ff52b69b6a48824fb54656913c3fe19
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="Core/ScriptableObject/Item/UsableItemSO.cs">
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Interaction
{
    [CreateAssetMenu(menuName = "Scriptable Objects/Item/Usable Item")]
    public class UsableItemSO : ItemSO
    {
        public List<BuffEffect> buffs;

        public override void UseItem()
        {
            base.UseItem();
            //
            for(int i = 0; i < buffs.Count; i++)
            {
                buffs[i].CreateAndApplyEffect();
            }
        }
    }
}
</file>

<file path="Core/ScriptableObject/Item/UsableItemSO.cs.meta">
fileFormatVersion: 2
guid: 5c2b18903d9f86f41810ead5417859ff
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="Core/ScriptableObject/Minigame.meta">
fileFormatVersion: 2
guid: 816e427761b0f6545900e1624fd5c95e
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="Core/ScriptableObject/Minigame/ChangeSceneEvent.cs">
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.SceneManagement;

namespace Interaction.Minigame
{
    [CreateAssetMenu(menuName = "Scriptable Objects/Minigame/Change Scene Event Data")]
    public class ChangeSceneEvent : MinigameDataSO
    {
        public string targetSceneName;
        Vector3 playerPosition;
        public override void Init(GameObject targetGameObject)
        {
            base.Init(targetGameObject);
            //
            playerPosition = GameObject.FindGameObjectWithTag("Player").transform.position;
            SceneManager.LoadScene(targetSceneName, LoadSceneMode.Additive);
            //
            SceneManager.sceneLoaded += OnSceneLoaded;
            SceneManager.sceneUnloaded += OnSceneUnload;
        }

        public void OnSceneLoaded(Scene scene, LoadSceneMode mode)
        {
            if(scene.name.Equals(targetSceneName))
            {
                SceneManager.sceneLoaded -= OnSceneLoaded;
                //
                SubSceneGameManager.instance.InitGame(targetNPC, this, targetSceneName);
            }
        }

        public void OnSceneUnload(Scene scene)
        {
            if (scene.name.Equals(targetSceneName))
            {
                SceneManager.sceneUnloaded -= OnSceneUnload;
                GameObject.FindGameObjectWithTag("Player").GetComponent<Rigidbody>().position = playerPosition;
            }
        }
    }
}
</file>

<file path="Core/ScriptableObject/Minigame/ChangeSceneEvent.cs.meta">
fileFormatVersion: 2
guid: 1cc1f45e91213184c902dd175424fa9b
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="Core/ScriptableObject/Minigame/LootEventSO.cs">
using System;
using System.Collections.Generic;
using UnityEngine;

namespace Interaction.Minigame
{
    [CreateAssetMenu(menuName = "Scriptable Objects/Minigame/Loot Event Data")]
    public class LootEventSO : MinigameDataSO
    {
        public List<LootObject> lootObjects;
        public int numberOfLoot;
        public override void Init(GameObject targetGameObject)
        {
            base.Init(targetGameObject);
            //
            GameObject parent = new GameObject();
            for(int i = 0; i < lootObjects.Count; i++)
            {
                Instantiate(lootObjects[i].prefabs, parent.transform);   
            }

            CollectQuestManager.instance.InitCollectQuest(targetGameObject, parent, this);
        }
    }

    [Serializable]
    public class LootObject
    {
        public GameObject prefabs;
    }
}
</file>

<file path="Core/ScriptableObject/Minigame/LootEventSO.cs.meta">
fileFormatVersion: 2
guid: 8ea2fe982b9cf534f834cceeb9935731
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="Core/ScriptableObject/Minigame/MinigameDataSO.cs">
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class MinigameDataSO : ScriptableObject
{
    public string minigameId;
    public string questId;
    public string stepId;
    public GameObject targetNPC;

    public virtual void Init(GameObject targetGameObject)
    {
        targetNPC = targetGameObject;
    }

    private void OnValidate()
    {
#if UNITY_EDITOR
        minigameId = questId + "_" + stepId;
#endif
    }
}
</file>

<file path="Core/ScriptableObject/Minigame/MinigameDataSO.cs.meta">
fileFormatVersion: 2
guid: 31610bc788cd81d4daa6403c6de288a8
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="Core/ScriptableObject/Minigame/QuizConservationSO.cs">
using System.Collections;
using System.Collections.Generic;
using UnityEditor;
using UnityEngine;

namespace Interaction.Minigame {
    [CreateAssetMenu(menuName = "Scriptable Objects/Minigame/Quiz Conservation Data")]
    public class QuizConservationSO : MinigameDataSO
    {
        public int numberOfQuestion;
        public int numberOfMaxWrong;
        public List<QuestionAndAnswer> qnas;
        public DialogConservation quizIntro;

        public override void Init(GameObject targetGameObject)
        {
            QuizManager.instance.InitAndStartQuizData(targetGameObject, this);
        }
    }

    [System.Serializable]
    public class QuestionAndAnswer
    {
        [TextArea(2,4)]
        public string Question;
        public string[] Answers;
        public int CorrectAnswer;
        [TextArea(2, 4)]
        public string Explaination;
    }
}
</file>

<file path="Core/ScriptableObject/Minigame/QuizConservationSO.cs.meta">
fileFormatVersion: 2
guid: 8675033c89e01e045840dacd37af3fa5
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="Core/ScriptableObject/New NPC Conservation SO.asset">
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!114 &11400000
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 318c5d99a71aed9408ed957fc30a9555, type: 3}
  m_Name: New NPC Conservation SO
  m_EditorClassIdentifier: 
  conservationId: NORMAL
  npcState: 0
  questId: 
  stepId: 
  startFromFirstDialog: 0
  dialogs:
  - dialogId: 
    message: 
    nodeSize: {x: 0, y: 0}
    voice: {fileID: 0}
    possibleResponses: []
    nodePosition: {x: 0, y: 0}
</file>

<file path="Core/ScriptableObject/New NPC Conservation SO.asset.meta">
fileFormatVersion: 2
guid: 8dcf1b973b3237041affec1b1643f232
NativeFormatImporter:
  externalObjects: {}
  mainObjectFileID: 11400000
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="Core/ScriptableObject/NPCConservationSO.cs">
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Interaction
{
    [CreateAssetMenu(menuName = "Scriptable Objects/NPC/Conservation Data")]


    #region NPCConservationSO là gì
    /*--------------------------------------------------------------------------------------------------------------------------------------------*/

    /* NPCConservationSO là một Scriptable Object quản lý dữ liệu hội thoại của NPC */

    /*--------------------------------------------------------------------------------------------------------------------------------------------*/

    #endregion


    public class NPCConservationSO : ScriptableObject
    {
        public string conservationId;
        public NPCState npcState;
        public string questId;
        public string stepId;

        public bool startFromFirstDialog;
        public List<DialogConservation> dialogs;


        #region Phương thức GetDialog 
        /*--------------------------------------------------------------------------------------------------------------------------------------------*/

        /* Trả về dialog có ID được chỉ định */

        /*--------------------------------------------------------------------------------------------------------------------------------------------*/

        #endregion

        public DialogConservation GetDialog(string id)
        {
            int index = GetDialogIndex(id);
            if (index != -1)
            {
                return dialogs[index];
            } else
            {
                return null;
            }
        }


        #region Phương thức GetDialogIndex 
        /*--------------------------------------------------------------------------------------------------------------------------------------------*/

        /* Trả về vị trí index của dialog trong list */

        /*--------------------------------------------------------------------------------------------------------------------------------------------*/

        #endregion

        public int GetDialogIndex(string id)
        {
            for (int i = 0; i < dialogs.Count; i ++)
            {
                if (dialogs[i].dialogId.Equals(id))
                {
                    return i;
                }
            }
            return -1;
        }

        private void OnValidate()
        {
#if UNITY_EDITOR
            conservationId = npcState + (questId != "" ? ("_" + questId) : "")  + (stepId != ""? ("_" + stepId) : "");
            UnityEditor.EditorUtility.SetDirty(this);
#endif
        }
    }

    
    [System.Serializable]
    public class DialogConservation
    {
        public string dialogId;
        [TextArea(5, 10)]
        public string message;
        public Vector2 nodeSize = new Vector2(200, 100); // Kích thước mặc định
        public AudioClip voice;
        public List<DialogResponse> possibleResponses;

        //editor
        [HideInInspector] public Vector2 nodePosition;

        public DialogConservation()
        {
            possibleResponses = new List<DialogResponse>();
            dialogId = "";
            message = "";
            nodePosition = new Vector2(10, 10);
        }
    }

    [System.Serializable]
    public class DialogResponse
    {
        [TextArea(1, 2)]
        public string message;
        public Sprite icon;
        public string nextDialogId;
        public DialogExecuteFunction executedFunction;

        public DialogResponse()
        {
            message = "";
            icon = null;
            nextDialogId = "";
            executedFunction = DialogExecuteFunction.None;
        }
    }

    public enum DialogExecuteFunction
    {
        None,
        //Interaction handle
        StopInteract,
        
        //Quest step handle - NPC Controller
        FinishQuestStep,
        StartQuestMinigame,
        FinishQuestStepThenStartMinigame,
        OnQuestMinigameFail,
        OnQuestMinigameSuccess,

        //Quiz handle - Quiz Manager
        NextQuiz,
        AnswerCorrect,
        AnswerWrong,

        //Functional Window - NPC Controller
        OpenShopFunctionalWindow
    }
}
</file>

<file path="Core/ScriptableObject/NPCConservationSO.cs.meta">
fileFormatVersion: 2
guid: 318c5d99a71aed9408ed957fc30a9555
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="Core/ScriptableObject/NPCInfoSO.cs">
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Interaction
{
    [CreateAssetMenu(menuName = "Scriptable Objects/NPC/NPC Info")]

    #region NPCInfoSO là gì
    /*--------------------------------------------------------------------------------------------------------------------------------------------*/

    /* NPCInfoSO là một Scriptable Object chứa thông tin cơ bản về NPC (Non-Player Character) trong game */

    /*--------------------------------------------------------------------------------------------------------------------------------------------*/

    #endregion

    public class NPCInfoSO : ScriptableObject
    {
        public string npcId;
        public string npcName;
        public string npcRole;
        public NPCConservationSO normalConservation;

        private void OnValidate()
        {
#if UNITY_EDITOR
            npcId = this.name;
#endif
        }
    }

    public enum NPCState
    {
        NORMAL,
        HAVE_QUEST,
        IN_PROGRESS,
        QUEST_COMPLETE,
        COUNTDOWN
    }
}
</file>

<file path="Core/ScriptableObject/NPCInfoSO.cs.meta">
fileFormatVersion: 2
guid: 98b252ce2f637574a9ccc15449c628ad
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="DialogueSystem.meta">
fileFormatVersion: 2
guid: d7d04cacedc277449ba00d79ee3e7f1b
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="DialogueSystem/CollectionUltility.cs">
using System.Collections.Generic;

namespace DS.Utilities
{
    public static class CollectionUtility
    {
        public static void AddItem<T, K>(this SerializableDictionary<T, List<K>> serializableDictionary, T key, K value)
        {
            if (serializableDictionary.ContainsKey(key))
            {
                serializableDictionary[key].Add(value);

                return;
            }

            serializableDictionary.Add(key, new List<K>() { value });
        }
    }
}
</file>

<file path="DialogueSystem/CollectionUltility.cs.meta">
fileFormatVersion: 2
guid: 6e1dd8840798e2c42b1736d18cb8bd9e
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="DialogueSystem/Data.meta">
fileFormatVersion: 2
guid: b1a956f0931b278439d223a4db170767
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="DialogueSystem/Data/Error.meta">
fileFormatVersion: 2
guid: bcd8ed2031457e248a1b6ed1acb97b25
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="DialogueSystem/Data/Error/DSErrorData.cs">
using UnityEngine;

namespace DS.Data.Error
{
    public class DSErrorData
    {
        public Color Color { get; set; }

        public DSErrorData()
        {
            GenerateRandomColor();
        }

        private void GenerateRandomColor()
        {
            Color = new Color32(
                (byte)Random.Range(65, 256),
                (byte)Random.Range(50, 176),
                (byte)Random.Range(50, 176),
                255
            );
        }
    }
}
</file>

<file path="DialogueSystem/Data/Error/DSErrorData.cs.meta">
fileFormatVersion: 2
guid: 5e1dc23c9f218544c8ed2faf842d3976
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="DialogueSystem/Data/Error/DSGroupErrorData.cs">
using System.Collections;
using System.Collections.Generic;
using System.Text.RegularExpressions;
using UnityEngine;

namespace DS.Data.Error
{
    using Elements;

    public class DSGroupErrorData
    {
        public DSErrorData DSErrorData { get; set; }

        public List<DSGroup> Groups { get; set; } 

        public DSGroupErrorData()
        {
            DSErrorData = new DSErrorData();

            Groups = new List<DSGroup>();
        }

    }

}
</file>

<file path="DialogueSystem/Data/Error/DSGroupErrorData.cs.meta">
fileFormatVersion: 2
guid: 28de271cf6e056a4f8753fc0ea37e0df
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="DialogueSystem/Data/Error/DSNodeErrorData.cs">
using System.Collections.Generic;

namespace DS.Data.Error
{
    using Elements;

    public class DSNodeErrorData
    {
        public DSErrorData ErrorData { get; set; }
        public List<DSNode> Nodes { get; set; }

        public DSNodeErrorData()
        {
            ErrorData = new DSErrorData();
            Nodes = new List<DSNode>();
        }
    }
}
</file>

<file path="DialogueSystem/Data/Error/DSNodeErrorData.cs.meta">
fileFormatVersion: 2
guid: e3beae36cfd142f4c9b66960ce8346ec
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="DialogueSystem/Data/Save.meta">
fileFormatVersion: 2
guid: e5c5032d9aa3efa4084d25e44bb97809
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="DialogueSystem/Data/Save/DSChoiceSaveData.cs">
using Interaction;
using System;
using UnityEngine;

namespace DS.Data.Save
{
    [Serializable]
    public class DSChoiceSaveData
    {
        [field: SerializeField] public string Text { get; set; }
        [field: SerializeField] public string NodeID { get; set; }

        [field: SerializeField] public DialogExecuteFunction ExecutedFunction { get; set; }
    }
}
</file>

<file path="DialogueSystem/Data/Save/DSChoiceSaveData.cs.meta">
fileFormatVersion: 2
guid: b4357b064f57428489cb87618b059d81
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="DialogueSystem/Data/Save/DSGraphSaveDataSO.cs">
using System.Collections.Generic;
using UnityEngine;

namespace DS.Data.Save
{
    public class DSGraphSaveDataSO : ScriptableObject
    {
        [field: SerializeField] public string FileName { get; set; }
        [field: SerializeField] public List<DSGroupSaveData> Groups { get; set; }
        [field: SerializeField] public List<DSNodeSaveData> Nodes { get; set; }
        [field: SerializeField] public List<string> OldGroupNames { get; set; }
        [field: SerializeField] public List<string> OldUngroupedNodeNames { get; set; }
        [field: SerializeField] public SerializableDictionary<string, List<string>> OldGroupedNodeNames { get; set; }

        public void Initialize(string fileName)
        {
            FileName = fileName;

            Groups = new List<DSGroupSaveData>();

            Nodes = new List<DSNodeSaveData>();
        }
    }
}
</file>

<file path="DialogueSystem/Data/Save/DSGraphSaveDataSO.cs.meta">
fileFormatVersion: 2
guid: 93b428b8e278e3f47b92553995e985de
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="DialogueSystem/Data/Save/DSGroupSaveData.cs">
using System;
using UnityEngine;

namespace DS.Data.Save
{
    [Serializable]
    public class DSGroupSaveData
    {
        [field: SerializeField] public string ID { get; set; }
        [field: SerializeField] public string Name { get; set; }
        [field: SerializeField] public Vector2 Position { get; set; }
    }
}
</file>

<file path="DialogueSystem/Data/Save/DSGroupSaveData.cs.meta">
fileFormatVersion: 2
guid: 13301fb0739404946a30e00feb2f0b99
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="DialogueSystem/Data/Save/DSNodeSaveData.cs">
using System;
using System.Collections.Generic;
using UnityEngine;

namespace DS.Data.Save
{
    using Enumerations;

    [Serializable]
    public class DSNodeSaveData
    {
        [field: SerializeField] public string ID { get; set; }
        [field: SerializeField] public string Name { get; set; }
        [field: SerializeField] public string Text { get; set; }
        [field: SerializeField] public List<DSChoiceSaveData> Choices { get; set; }
        [field: SerializeField] public string GroupID { get; set; }
        [field: SerializeField] public DSDialogType DialogueType { get; set; }
        [field: SerializeField] public Vector2 Position { get; set; }
    }
}
</file>

<file path="DialogueSystem/Data/Save/DSNodeSaveData.cs.meta">
fileFormatVersion: 2
guid: 7f2abe5336b84204fa7501b2688f39d9
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="DialogueSystem/Elements.meta">
fileFormatVersion: 2
guid: a2c41472b19e52346904d35781b10a2b
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="DialogueSystem/Elements/DSGroup.cs">
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEditor.Experimental.GraphView;
using UnityEngine;

namespace DS.Elements 
{
    public class DSGroup : Group
    {
        public string ID { get; set; }

        public string oldtitle { get; set; }

        private Color defaultBorderColor;

        private float defaultBorderWidth;   

        public DSGroup(string groupTitle, Vector2 position)
        {
            ID = Guid.NewGuid().ToString(); 

            title = groupTitle;

            oldtitle = groupTitle;

            SetPosition(new Rect(position, Vector2.zero));

            defaultBorderColor = contentContainer.style.borderBottomColor.value;

            defaultBorderWidth = contentContainer.style.borderBottomWidth.value; 
        }

        public void SetErrorStyle(Color color)
        {
            contentContainer.style.borderBottomColor = color;

            contentContainer.style.borderBottomWidth = 2f;
        }

        public void ResetStyle()
        {
            contentContainer.style.borderBottomColor = defaultBorderColor;

            contentContainer.style.borderBottomWidth = defaultBorderWidth;
        }
    }
}
</file>

<file path="DialogueSystem/Elements/DSGroup.cs.meta">
fileFormatVersion: 2
guid: 166a47388d82d524da4408870510e5d0
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="DialogueSystem/Elements/DSMultipleChoiceNode.cs">
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace DS.Elements
{
    using Data.Save;
    using Enumerations;
    using UnityEditor.Experimental.GraphView;
    using UnityEngine.UIElements;
    using Ultilities;
    using windows;
    using System.Net;

    public class DSMultipleChoiceNode : DSNode
    {
    
        public override void Initialize(string nodeName, DSGraphView dSGraphView, Vector2 position)
        {
            base.Initialize(nodeName, dSGraphView, position);

            DialogueType = DSDialogType.MultipleChoice;

            DSChoiceSaveData choiceData = new DSChoiceSaveData()
            {
                Text = "New Choice"
            };

            Choices.Add(choiceData);
        }
        public override void Draw()
        {
            base.Draw();

            /* MAIN CONTAINER */
            Button addChoiceButton = DSElementsUltilities.CreateButton("Add choice", () =>
            {

                DSChoiceSaveData choiceData = new DSChoiceSaveData()
                {
                    Text = "New Choice"
                };
                          
                Choices.Add(choiceData);

                Port choicePort = CreateChoicePort(choiceData);

                outputContainer.Add(choicePort);
            });

            addChoiceButton.AddToClassList("ds-node__button");

            mainContainer.Insert(1, addChoiceButton);

            /* OUTPUT CONTAINER */
            foreach (DSChoiceSaveData choice in Choices)
            {
                Port choicePort = CreateChoicePort(choice);

                outputContainer.Add(choicePort);
            }

            RefreshExpandedState();
        }

        private Port CreateChoicePort(object userData)
        {
            Port ChoicePort = this.CreatePort();

            ChoicePort.userData = userData;

            DSChoiceSaveData ChoiceData = (DSChoiceSaveData) userData;

            ChoicePort.portName = "";

            Button DeleteChoiceButton = DSElementsUltilities.CreateButton("X", () =>
            {
                if(Choices.Count == 1)
                {
                    return;
                }

                if(ChoicePort.connected)
                {
                    graphView.DeleteElements(ChoicePort.connections);
                }

                Choices.Remove(ChoiceData);

                graphView.RemoveElement(ChoicePort);
            });

            TextField choicetextField = DSElementsUltilities.CreateTextField(ChoiceData.Text, null, callback =>
            {
                ChoiceData.Text = callback.newValue;
            });

            choicetextField.style.flexDirection = FlexDirection.Column; // Dòng này sửa lỗi inputContainer và outputContainer dính vào nhau 

            choicetextField.AddClasses(
                "ds-node__textfield",
                "ds-node__choice-textfield",
                "ds-node__textfield__hidden"
                );
        
            ChoicePort.Add(choicetextField);

            ChoicePort.Add(DeleteChoiceButton);

            return ChoicePort;
        }

    }
}
</file>

<file path="DialogueSystem/Elements/DSMultipleChoiceNode.cs.meta">
fileFormatVersion: 2
guid: 22972e2102a1dd0478eb9803c199614c
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="DialogueSystem/Elements/DSNode.cs">
using System.Collections;
using System.Collections.Generic;
using UnityEditor.Experimental.GraphView;
using UnityEngine;

namespace DS.Elements
{
    using Data.Save;
    using Enumerations;
    using UnityEngine.UIElements;
    using Ultilities;
    using DS.windows;
    using System;
    using System.Linq;
    using Interaction;

    public class DSNode : Node
    {
        public string ID { get; set; }  

        public string DialogName { get; set; }

        public List<DSChoiceSaveData> Choices { get; set; }

        public string Text { get; set; }

        public DSDialogType DialogueType { get; set; }

        public DialogExecuteFunction ExecutedFunction { get; set; } = DialogExecuteFunction.None;

        public DSGroup Group { get; set; }

        protected DSGraphView graphView;

        private Color defaultBackgroundColor;

        public virtual void Initialize(string nodeName, DSGraphView dSGraphView,Vector2 position)
        {
            ID = Guid.NewGuid().ToString();

            DialogName = nodeName;

            Choices = new List<DSChoiceSaveData>();

            Text = "Dialogue text.";

            graphView = dSGraphView;

            defaultBackgroundColor = new Color(29f / 255f, 29f / 255f, 30f / 255f);

            SetPosition(new Rect(position,Vector2.zero));

            mainContainer.AddToClassList("ds-node__main-container");

            extensionContainer.AddToClassList("ds-node__extension-container");
        }

        #region Override

        public override void BuildContextualMenu(ContextualMenuPopulateEvent evt)
        {
            evt.menu.AppendAction("Disconnect Input Port", actionEvent => DisconnectInputPort());

            evt.menu.AppendAction("Disconnect Output Port", actionEvent => DisconnectOutputPort());

            base.BuildContextualMenu(evt);
        }

        #endregion

        public virtual void Draw()
        {
            /* TITLE CONTAINER */

            /*--------------------------------------------------------------------------------------------------------------------------------------------*/

            /* Callback trong dialogNameTexField được gọi mỗi khi giá trị của TextField thay đổi.*/

            /*--------------------------------------------------------------------------------------------------------------------------------------------*/

            TextField dialogNameTexField = DSElementsUltilities.CreateTextField(DialogName, null, callback =>
            {
                TextField target = (TextField) callback.target;

                target.value = callback.newValue.RemoveWhitespaces().RemoveSpecialCharacters();

                if (string.IsNullOrEmpty(target.value))
                {
                    if (!string.IsNullOrEmpty(DialogName))
                    {
                        ++graphView.NameErrorAmount;
                    }
                }
                else
                {
                    if (string.IsNullOrEmpty(DialogName))
                    {
                        --graphView.NameErrorAmount;
                    }
                }

                if (Group == null)
                {
                    graphView.RemoveUnGroupNode(this);

                    /*Nếu muốn có WhiteSpaces cho Nodes thì thay DialogName bằng callback.newValue*/
                    DialogName = target.value;

                    graphView.AddUnGroupNode(this);

                    return;
                } 
                
                DSGroup currentGroup = Group;

                graphView.RemoveGroupedNode(this, Group);

                DialogName = callback.newValue;

                graphView.AddGroupedNode(this, currentGroup);

            });

            dialogNameTexField.AddClasses(
                "ds-node__textfield",
                "ds-node__filename-textfield",
                "ds-node__textfield__hidden"
                );

            titleContainer.Insert(0, dialogNameTexField);

            /* INPUT CONTAINER */

            Port inputPort = this.CreatePort("Dialog Connection", Orientation.Horizontal, Direction.Input, Port.Capacity.Multi);

            inputContainer.Add(inputPort);

            /* EXTENSION CONTAINER */

            VisualElement customdatacontainer = new VisualElement();

            customdatacontainer.AddToClassList("ds-node__custom-data-container");

            Foldout textFoldout = DSElementsUltilities.CreateFoldout("Dialogue Text");

            TextField textTextField = DSElementsUltilities.CreateTextArea(Text, null, callback => Text = callback.newValue);

            textTextField.AddClasses(
                "ds-node__textfield",
                "ds-node__qute-textfield"
                );
        
            textFoldout.Add(textTextField);

            customdatacontainer.Add(textFoldout);

            extensionContainer.Add(customdatacontainer);

            EnumField executedFunctionField = new EnumField("Node Function", ExecutedFunction);
            executedFunctionField.Init(DialogExecuteFunction.None);
            executedFunctionField.RegisterValueChangedCallback(evt =>
            {
                ExecutedFunction = (DialogExecuteFunction)evt.newValue;
            });

            executedFunctionField.style.marginTop = 4;
            executedFunctionField.style.minWidth = 150;

            // Gắn vào container phù hợp
            extensionContainer.Add(executedFunctionField);


        }

        public void DisconnectAllPorts()
        {
            DisconnectInputPort();

            DisconnectOutputPort();
        }

        private void DisconnectInputPort()
        {
            DisconnectPort(inputContainer);
        }

        private void DisconnectOutputPort()
        {
            DisconnectPort(outputContainer);
        }

        #region  Định nghĩa port.conected và port.connection

        /*--------------------------------------------------------------------------------------------------------------------------------------------*/

        /*

        1. port.connected

        ✅ Kiểu dữ liệu: bool (Boolean – true/false)

        ✅ Ý nghĩa:

        - Cho biết Port đó có đang kết nối với cổng khác không.

        ✅ Trả về:

        - true nếu có ít nhất một kết nối

        - false nếu chưa được kết nối với bất kỳ Port nào

        2. port.connections

        ✅ Kiểu dữ liệu: IEnumerable<Edge>

        ✅ Ý nghĩa:

        - Trả về tập hợp tất cả các Edge (đường kết nối) được nối vào Port này.

        - Mỗi Edge đại diện cho một kết nối giữa 2 Port.

        ✅ Dùng để:

        - Duyệt qua các kết nối, ví dụ để xóa, sửa, hiển thị.

        - Lấy Port đối diện bằng cách xem Edge.input và Edge.output.

        */
        /*--------------------------------------------------------------------------------------------------------------------------------------------*/

        #endregion

        private void DisconnectPort(VisualElement container)
        {
            foreach(Port port in container.Children())
            {
                if (!port.connected)
                {
                    continue;
                }

                graphView.DeleteElements(port.connections);
            }
        }

        public bool IsStartingNode()
        {
            Port inputPort = (Port)inputContainer.Children().First();

            return !inputPort.connected;
        }

        public void SetErrorStyle(Color color)
        {
            mainContainer.style.backgroundColor = color;
        }


        public void ResetStyle()
        {
            mainContainer.style.backgroundColor = defaultBackgroundColor;
        }
    }
}
</file>

<file path="DialogueSystem/Elements/DSNode.cs.meta">
fileFormatVersion: 2
guid: f822b60412134e048a651bedf3ee6b60
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="DialogueSystem/Elements/DSSingleChoiceNode.cs">
using System.Collections;
using System.Collections.Generic;
using UnityEditor.Experimental.GraphView;
using UnityEngine;


 namespace DS.Elements
{
    using Data.Save;
    using Enumerations;
    using Ultilities;
    using windows;

    public class DSSingleChoiceNode : DSNode
    {
        public override void Initialize(string nodeName, DSGraphView dSGraphView, Vector2 position)
        {
            base.Initialize(nodeName, dSGraphView, position);

            DialogueType = DSDialogType.SingleChoice;

            DSChoiceSaveData choiceData = new DSChoiceSaveData()
            {
                Text = "Next Dialogue"
            };

            Choices.Add(choiceData);

        }
        public override void Draw()
        {
            base.Draw();
          
            /* OUTPUT CONTAINER */
            foreach (DSChoiceSaveData choice in Choices)
            {
                Port ChoicePort = this.CreatePort(choice.Text);

                ChoicePort.userData = choice;

                ChoicePort.portName = choice.Text;

                outputContainer.Add(ChoicePort);
            }
            RefreshExpandedState();
        }

        
    }


}
</file>

<file path="DialogueSystem/Elements/DSSingleChoiceNode.cs.meta">
fileFormatVersion: 2
guid: ee10252108fa04e4999f829d07b68275
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="DialogueSystem/Graphs.meta">
fileFormatVersion: 2
guid: b1f3b6bd2fa709940a570a3c09d9dc12
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="DialogueSystem/Graphs/cGraph.asset">
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!114 &11400000
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 93b428b8e278e3f47b92553995e985de, type: 3}
  m_Name: cGraph
  m_EditorClassIdentifier: 
  <FileName>k__BackingField: c
  <Groups>k__BackingField: []
  <Nodes>k__BackingField:
  - <ID>k__BackingField: 43f4c5a3-b042-44ea-985b-d67d70ea6f72
    <Name>k__BackingField: a
    <Text>k__BackingField: zzzz
    <Choices>k__BackingField:
    - <Text>k__BackingField: Next Dialogue
      <NodeID>k__BackingField: 07c40e3d-76b0-4650-bc2a-c26a95b3c7f9
      <ExecutedFunction>k__BackingField: 0
    <GroupID>k__BackingField: 
    <DialogueType>k__BackingField: 0
    <Position>k__BackingField: {x: 84, y: 142.40001}
  - <ID>k__BackingField: 01e42fc7-4c07-47dc-8317-c02880cc4ab0
    <Name>k__BackingField: DialogueName
    <Text>k__BackingField: Dialogue text.
    <Choices>k__BackingField:
    - <Text>k__BackingField: Next Dialogue
      <NodeID>k__BackingField: 
      <ExecutedFunction>k__BackingField: 0
    <GroupID>k__BackingField: 
    <DialogueType>k__BackingField: 0
    <Position>k__BackingField: {x: 707.2, y: 213.6}
  - <ID>k__BackingField: 07c40e3d-76b0-4650-bc2a-c26a95b3c7f9
    <Name>k__BackingField: zzzz
    <Text>k__BackingField: cccc
    <Choices>k__BackingField:
    - <Text>k__BackingField: x
      <NodeID>k__BackingField: 01e42fc7-4c07-47dc-8317-c02880cc4ab0
      <ExecutedFunction>k__BackingField: 0
    <GroupID>k__BackingField: 
    <DialogueType>k__BackingField: 1
    <Position>k__BackingField: {x: 460, y: 140.8}
  <OldGroupNames>k__BackingField: []
  <OldUngroupedNodeNames>k__BackingField:
  - a
  - DialogueName
  - zzzz
  <OldGroupedNodeNames>k__BackingField:
    list: []
</file>

<file path="DialogueSystem/Graphs/cGraph.asset.meta">
fileFormatVersion: 2
guid: 44fb98336d00e33499c4c0f9627347b8
NativeFormatImporter:
  externalObjects: {}
  mainObjectFileID: 11400000
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="DialogueSystem/Graphs/test1Graph.asset">
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!114 &11400000
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 93b428b8e278e3f47b92553995e985de, type: 3}
  m_Name: test1Graph
  m_EditorClassIdentifier: 
  <FileName>k__BackingField: test1
  <Groups>k__BackingField:
  - <ID>k__BackingField: 7d1fd976-0c77-4b77-9aba-fb67e55db30e
    <Name>k__BackingField: NORMAL
    <Position>k__BackingField: {x: 1433.0001, y: -271}
  <Nodes>k__BackingField:
  - <ID>k__BackingField: 4cb0ce11-6868-47e6-956c-c38f278ce99e
    <Name>k__BackingField: node2
    <Text>k__BackingField: zzzzz
    <Choices>k__BackingField:
    - <Text>k__BackingField: New Choice
      <NodeID>k__BackingField: d0363c0f-6df2-4de2-baa9-52ee777e94cc
      <ExecutedFunction>k__BackingField: 0
    <GroupID>k__BackingField: 
    <DialogueType>k__BackingField: 1
    <Position>k__BackingField: {x: 439, y: 4}
  - <ID>k__BackingField: d0363c0f-6df2-4de2-baa9-52ee777e94cc
    <Name>k__BackingField: node3
    <Text>k__BackingField: Dialogue text.
    <Choices>k__BackingField:
    - <Text>k__BackingField: New Choice
      <NodeID>k__BackingField: 
      <ExecutedFunction>k__BackingField: 0
    - <Text>k__BackingField: New Choice
      <NodeID>k__BackingField: 
      <ExecutedFunction>k__BackingField: 0
    - <Text>k__BackingField: New Choice
      <NodeID>k__BackingField: 4a088501-6d64-44b5-8aa2-0fe9e63fbc6b
      <ExecutedFunction>k__BackingField: 0
    <GroupID>k__BackingField: 
    <DialogueType>k__BackingField: 1
    <Position>k__BackingField: {x: 826, y: -194}
  - <ID>k__BackingField: c4ba33f6-f802-46ba-9be7-8a339728ca15
    <Name>k__BackingField: node1
    <Text>k__BackingField: zzzz
    <Choices>k__BackingField:
    - <Text>k__BackingField: Next Dialogue
      <NodeID>k__BackingField: 4cb0ce11-6868-47e6-956c-c38f278ce99e
      <ExecutedFunction>k__BackingField: 0
    <GroupID>k__BackingField: 
    <DialogueType>k__BackingField: 0
    <Position>k__BackingField: {x: 135, y: -12}
  - <ID>k__BackingField: 34d70b4a-f955-4ddd-9214-e9a4ceb13d83
    <Name>k__BackingField: 1
    <Text>k__BackingField: "Xin ch\xE0o, em l\xE0 t\xE2n sinh vi\xEAn m\u1EDBi v\xE0o
      tr\u01B0\u1EDDng \u0111\xFAng kh\xF4ng"
    <Choices>k__BackingField:
    - <Text>k__BackingField: "D\u1EA1, \u0111\xFAng r\u1ED3i th\u1EA7y \u1EA1"
      <NodeID>k__BackingField: e37b1b45-3d51-4462-a222-32ef14356dc4
      <ExecutedFunction>k__BackingField: 0
    - <Text>k__BackingField: "D\u1EA1, em h\u1ECDc tr\u01B0\u1EDDng kh\xE1c \u1EA1"
      <NodeID>k__BackingField: 19311275-f68b-4ce4-a5dd-b4f8b8c3925d
      <ExecutedFunction>k__BackingField: 0
    <GroupID>k__BackingField: 7d1fd976-0c77-4b77-9aba-fb67e55db30e
    <DialogueType>k__BackingField: 1
    <Position>k__BackingField: {x: 1458, y: -99}
  - <ID>k__BackingField: e37b1b45-3d51-4462-a222-32ef14356dc4
    <Name>k__BackingField: 2
    <Text>k__BackingField: "T\xF4i c\xF3 m\u1ED9t s\u1ED1 c\xE2u h\u1ECFi, h\xE3y
      tr\u1EA3 l\u1EDDi \u0111\u1EC3 xem \u0111\u1ED9 hi\u1EC3u bi\u1EBFt c\u1EE7a
      em v\u1EC1 tr\u01B0\u1EDDng \u0111\u1EBFn \u0111\xE2u nh\xE9."
    <Choices>k__BackingField:
    - <Text>k__BackingField: "V\xE2ng \u1EA1"
      <NodeID>k__BackingField: 35d7635d-e7e2-4930-bfb9-f3588158d61a
      <ExecutedFunction>k__BackingField: 0
    - <Text>k__BackingField: ' v'
      <NodeID>k__BackingField: 
      <ExecutedFunction>k__BackingField: 0
    - <Text>k__BackingField: c
      <NodeID>k__BackingField: 
      <ExecutedFunction>k__BackingField: 0
    - <Text>k__BackingField: d
      <NodeID>k__BackingField: 
      <ExecutedFunction>k__BackingField: 0
    <GroupID>k__BackingField: 7d1fd976-0c77-4b77-9aba-fb67e55db30e
    <DialogueType>k__BackingField: 1
    <Position>k__BackingField: {x: 1924, y: -212}
  - <ID>k__BackingField: 19311275-f68b-4ce4-a5dd-b4f8b8c3925d
    <Name>k__BackingField: 3
    <Text>k__BackingField: "Th\xEC ra l\xE0 v\u1EADy. Mong em c\xF3 kho\u1EA3ng th\u1EDDi
      gian vui v\u1EBB t\u1EA1i tr\u01B0\u1EDDng."
    <Choices>k__BackingField:
    - <Text>k__BackingField: "V\xE2ng \u1EA1, em ch\xE0o th\u1EA7y."
      <NodeID>k__BackingField: 
      <ExecutedFunction>k__BackingField: 0
    <GroupID>k__BackingField: 7d1fd976-0c77-4b77-9aba-fb67e55db30e
    <DialogueType>k__BackingField: 1
    <Position>k__BackingField: {x: 1975, y: 87}
  - <ID>k__BackingField: 35d7635d-e7e2-4930-bfb9-f3588158d61a
    <Name>k__BackingField: 4
    <Text>k__BackingField: "C\xE1c th\xF4ng tin v\u1EC1 c\xE2u h\u1ECFi n\u1EB1m
      trong ph\u1EA7n \"T\xECm hi\u1EC3u kh\xE1i qu\xE1t v\u1EC1 H\u1ECDc Vi\u1EC7n\"
      n\u1EB1m trong \u0111i\u1EC7n tho\u1EA1i c\u1EE7a em. H\xE3y quay l\u1EA1i
      g\u1EB7p th\u1EA7y khi em \u0111\xE3 s\u1EB5n s\xE0ng."
    <Choices>k__BackingField:
    - <Text>k__BackingField: "V\xE2ng \u1EA1, em ch\xE0o th\u1EA7y."
      <NodeID>k__BackingField: a5bb6e11-4e4d-40d2-979e-029b02a509ec
      <ExecutedFunction>k__BackingField: 0
    <GroupID>k__BackingField: 7d1fd976-0c77-4b77-9aba-fb67e55db30e
    <DialogueType>k__BackingField: 1
    <Position>k__BackingField: {x: 2491, y: -35}
  - <ID>k__BackingField: 4a088501-6d64-44b5-8aa2-0fe9e63fbc6b
    <Name>k__BackingField: node4
    <Text>k__BackingField: Dialogue text.
    <Choices>k__BackingField:
    - <Text>k__BackingField: Next Dialogue
      <NodeID>k__BackingField: 
      <ExecutedFunction>k__BackingField: 0
    <GroupID>k__BackingField: 
    <DialogueType>k__BackingField: 0
    <Position>k__BackingField: {x: 832, y: 259}
  - <ID>k__BackingField: a5bb6e11-4e4d-40d2-979e-029b02a509ec
    <Name>k__BackingField: null
    <Text>k__BackingField: 
    <Choices>k__BackingField:
    - <Text>k__BackingField: Next Dialogue
      <NodeID>k__BackingField: 
      <ExecutedFunction>k__BackingField: 0
    <GroupID>k__BackingField: 7d1fd976-0c77-4b77-9aba-fb67e55db30e
    <DialogueType>k__BackingField: 0
    <Position>k__BackingField: {x: 3404, y: 89}
  <OldGroupNames>k__BackingField:
  - NORMAL
  <OldUngroupedNodeNames>k__BackingField:
  - node2
  - node3
  - node1
  - node4
  <OldGroupedNodeNames>k__BackingField:
    list:
    - Key: NORMAL
      Value:
      - 1
      - 2
      - 3
      - 4
      - null
</file>

<file path="DialogueSystem/Graphs/test1Graph.asset.meta">
fileFormatVersion: 2
guid: 891417718c9e6ae4e8a64155296f643d
NativeFormatImporter:
  externalObjects: {}
  mainObjectFileID: 11400000
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="DialogueSystem/Graphs/testGraph.asset">
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!114 &11400000
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 93b428b8e278e3f47b92553995e985de, type: 3}
  m_Name: testGraph
  m_EditorClassIdentifier: 
  <FileName>k__BackingField: test
  <Groups>k__BackingField:
  - <ID>k__BackingField: 7d1fd976-0c77-4b77-9aba-fb67e55db30e
    <Name>k__BackingField: g1
    <Position>k__BackingField: {x: 1532, y: -200.80002}
  <Nodes>k__BackingField:
  - <ID>k__BackingField: 4a088501-6d64-44b5-8aa2-0fe9e63fbc6b
    <Name>k__BackingField: node4
    <Text>k__BackingField: Dialogue text.
    <Choices>k__BackingField:
    - <Text>k__BackingField: Next Dialogue
      <NodeID>k__BackingField: 5238df5d-b108-4098-b329-9e68eae5e0f5
    <GroupID>k__BackingField: 
    <DialogueType>k__BackingField: 0
    <Position>k__BackingField: {x: 1188, y: 93.600006}
  - <ID>k__BackingField: 74a3a9a5-a170-4da3-9453-70906471434f
    <Name>k__BackingField: node2
    <Text>k__BackingField: zzzzz
    <Choices>k__BackingField:
    - <Text>k__BackingField: Next Dialogue
      <NodeID>k__BackingField: 
    <GroupID>k__BackingField: 7d1fd976-0c77-4b77-9aba-fb67e55db30e
    <DialogueType>k__BackingField: 0
    <Position>k__BackingField: {x: 1923.2, y: 1.5999985}
  - <ID>k__BackingField: c4ba33f6-f802-46ba-9be7-8a339728ca15
    <Name>k__BackingField: node1
    <Text>k__BackingField: Dialogue text.
    <Choices>k__BackingField:
    - <Text>k__BackingField: Next Dialogue
      <NodeID>k__BackingField: 4cb0ce11-6868-47e6-956c-c38f278ce99e
    <GroupID>k__BackingField: 
    <DialogueType>k__BackingField: 0
    <Position>k__BackingField: {x: 135.2, y: -12.000001}
  - <ID>k__BackingField: 4cb0ce11-6868-47e6-956c-c38f278ce99e
    <Name>k__BackingField: node2
    <Text>k__BackingField: Dialogue text.
    <Choices>k__BackingField:
    - <Text>k__BackingField: New Choice
      <NodeID>k__BackingField: d0363c0f-6df2-4de2-baa9-52ee777e94cc
    <GroupID>k__BackingField: 
    <DialogueType>k__BackingField: 1
    <Position>k__BackingField: {x: 439.2, y: 4}
  - <ID>k__BackingField: d0363c0f-6df2-4de2-baa9-52ee777e94cc
    <Name>k__BackingField: node3
    <Text>k__BackingField: Dialogue text.
    <Choices>k__BackingField:
    - <Text>k__BackingField: New Choice
      <NodeID>k__BackingField: 
    - <Text>k__BackingField: New Choice
      <NodeID>k__BackingField: 
    - <Text>k__BackingField: New Choice
      <NodeID>k__BackingField: 4a088501-6d64-44b5-8aa2-0fe9e63fbc6b
    <GroupID>k__BackingField: 
    <DialogueType>k__BackingField: 1
    <Position>k__BackingField: {x: 825.60004, y: -194.4}
  - <ID>k__BackingField: 5238df5d-b108-4098-b329-9e68eae5e0f5
    <Name>k__BackingField: node1
    <Text>k__BackingField: zzzz
    <Choices>k__BackingField:
    - <Text>k__BackingField: Next Dialogue
      <NodeID>k__BackingField: 74a3a9a5-a170-4da3-9453-70906471434f
    <GroupID>k__BackingField: 7d1fd976-0c77-4b77-9aba-fb67e55db30e
    <DialogueType>k__BackingField: 0
    <Position>k__BackingField: {x: 1557.6, y: -140.8}
  <OldGroupNames>k__BackingField:
  - g1
  <OldUngroupedNodeNames>k__BackingField:
  - node4
  - node1
  - node2
  - node3
  <OldGroupedNodeNames>k__BackingField:
    list:
    - Key: g1
      Value:
      - node2
      - node1
</file>

<file path="DialogueSystem/Graphs/testGraph.asset.meta">
fileFormatVersion: 2
guid: 78c37ddf5e87f7f4fabd09e7e9824f89
NativeFormatImporter:
  externalObjects: {}
  mainObjectFileID: 11400000
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="DialogueSystem/Graphs/zGraph.asset">
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!114 &11400000
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 93b428b8e278e3f47b92553995e985de, type: 3}
  m_Name: zGraph
  m_EditorClassIdentifier: 
  <FileName>k__BackingField: z
  <Groups>k__BackingField: []
  <Nodes>k__BackingField:
  - <ID>k__BackingField: 82ba5224-e88f-4fa4-830c-d4ff2863faf4
    <Name>k__BackingField: DialogueName
    <Text>k__BackingField: Dialogue text.
    <Choices>k__BackingField:
    - <Text>k__BackingField: Next Dialogue
      <NodeID>k__BackingField: 
    <GroupID>k__BackingField: 
    <DialogueType>k__BackingField: 0
    <Position>k__BackingField: {x: 514.4, y: -762.4}
  - <ID>k__BackingField: 69380b64-b4c6-4187-96c3-172761bac6e8
    <Name>k__BackingField: d
    <Text>k__BackingField: Dialogue text.
    <Choices>k__BackingField:
    - <Text>k__BackingField: Next Dialogue
      <NodeID>k__BackingField: 82ba5224-e88f-4fa4-830c-d4ff2863faf4
    <GroupID>k__BackingField: 
    <DialogueType>k__BackingField: 0
    <Position>k__BackingField: {x: 204, y: -740}
  <OldGroupNames>k__BackingField: []
  <OldUngroupedNodeNames>k__BackingField:
  - DialogueName
  - d
  <OldGroupedNodeNames>k__BackingField:
    list: []
</file>

<file path="DialogueSystem/Graphs/zGraph.asset.meta">
fileFormatVersion: 2
guid: 7b706c305f61c5844a5613e1a0aa17eb
NativeFormatImporter:
  externalObjects: {}
  mainObjectFileID: 11400000
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="DialogueSystem/Inspectors.meta">
fileFormatVersion: 2
guid: 2da41c427090061458ed3e784b923ac0
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="DialogueSystem/Inspectors/DSInspector.cs">
using System.Collections.Generic;
using UnityEditor;

namespace DS.Inspectors
{
    using Utilities;
    using ScriptableObjects;

    [CustomEditor(typeof(DSDialogue))]
    public class DSInspector : Editor
    {
        /* Dialogue Scriptable Objects */
        private SerializedProperty dialogueContainerProperty;
        private SerializedProperty dialogueGroupProperty;
        private SerializedProperty dialogueProperty;

        /* Filters */
        private SerializedProperty groupedDialoguesProperty;
        private SerializedProperty startingDialoguesOnlyProperty;

        /* Indexes */
        private SerializedProperty selectedDialogueGroupIndexProperty;
        private SerializedProperty selectedDialogueIndexProperty;

        private void OnEnable()
        {
            dialogueContainerProperty = serializedObject.FindProperty("dialogueContainer");
            dialogueGroupProperty = serializedObject.FindProperty("dialogueGroup");
            dialogueProperty = serializedObject.FindProperty("dialogue");

            groupedDialoguesProperty = serializedObject.FindProperty("groupedDialogues");
            startingDialoguesOnlyProperty = serializedObject.FindProperty("startingDialoguesOnly");

            selectedDialogueGroupIndexProperty = serializedObject.FindProperty("selectedDialogueGroupIndex");
            selectedDialogueIndexProperty = serializedObject.FindProperty("selectedDialogueIndex");
        }

        public override void OnInspectorGUI()
        {
            serializedObject.Update();

            DrawDialogueContainerArea();

            DSDialogueContainerSO currentDialogueContainer = (DSDialogueContainerSO)dialogueContainerProperty.objectReferenceValue;

            if (currentDialogueContainer == null)
            {
                StopDrawing("Select a Dialogue Container to see the rest of the Inspector.");

                return;
            }

            DrawFiltersArea();

            bool currentGroupedDialoguesFilter = groupedDialoguesProperty.boolValue;
            bool currentStartingDialoguesOnlyFilter = startingDialoguesOnlyProperty.boolValue;

            List<string> dialogueNames;

            string dialogueFolderPath = $"Assets/DialogSystem/Dialogues/{currentDialogueContainer.FileName}";

            string dialogueInfoMessage;

            if (currentGroupedDialoguesFilter)
            {
                List<string> dialogueGroupNames = currentDialogueContainer.GetDialogueGroupNames();

                if (dialogueGroupNames.Count == 0)
                {
                    StopDrawing("There are no Dialogue Groups in this Dialogue Container.");

                    return;
                }

                DrawDialogueGroupArea(currentDialogueContainer, dialogueGroupNames);

                DSDialogueGroupSO dialogueGroup = (DSDialogueGroupSO)dialogueGroupProperty.objectReferenceValue;

                dialogueNames = currentDialogueContainer.GetGroupedDialogueNames(dialogueGroup, currentStartingDialoguesOnlyFilter);

                dialogueFolderPath += $"/Groups/{dialogueGroup.GroupName}/Dialogues";

                dialogueInfoMessage = "There are no" + (currentStartingDialoguesOnlyFilter ? " Starting" : "") + " Dialogues in this Dialogue Group.";
            }
            else
            {
                dialogueNames = currentDialogueContainer.GetUngroupedDialogueNames(currentStartingDialoguesOnlyFilter);

                dialogueFolderPath += "/Global/Dialogues";

                dialogueInfoMessage = "There are no" + (currentStartingDialoguesOnlyFilter ? " Starting" : "") + " Ungrouped Dialogues in this Dialogue Container.";
            }

            if (dialogueNames.Count == 0)
            {
                StopDrawing(dialogueInfoMessage);

                return;
            }

            DrawDialogueArea(dialogueNames, dialogueFolderPath);

            serializedObject.ApplyModifiedProperties();
        }

        private void DrawDialogueContainerArea()
        {
            DSInspectorUtility.DrawHeader("Dialogue Container");

            dialogueContainerProperty.DrawPropertyField();

            DSInspectorUtility.DrawSpace();
        }

        private void DrawFiltersArea()
        {
            DSInspectorUtility.DrawHeader("Filters");

            groupedDialoguesProperty.DrawPropertyField();
            startingDialoguesOnlyProperty.DrawPropertyField();

            DSInspectorUtility.DrawSpace();
        }

        private void DrawDialogueGroupArea(DSDialogueContainerSO dialogueContainer, List<string> dialogueGroupNames)
        {
            DSInspectorUtility.DrawHeader("Dialogue Group");

            int oldSelectedDialogueGroupIndex = selectedDialogueGroupIndexProperty.intValue;

            DSDialogueGroupSO oldDialogueGroup = (DSDialogueGroupSO)dialogueGroupProperty.objectReferenceValue;

            bool isOldDialogueGroupNull = oldDialogueGroup == null;

            string oldDialogueGroupName = isOldDialogueGroupNull ? "" : oldDialogueGroup.GroupName;

            UpdateIndexOnNamesListUpdate(dialogueGroupNames, selectedDialogueGroupIndexProperty, oldSelectedDialogueGroupIndex, oldDialogueGroupName, isOldDialogueGroupNull);

            selectedDialogueGroupIndexProperty.intValue = DSInspectorUtility.DrawPopup("Dialogue Group", selectedDialogueGroupIndexProperty, dialogueGroupNames.ToArray());

            string selectedDialogueGroupName = dialogueGroupNames[selectedDialogueGroupIndexProperty.intValue];

            DSDialogueGroupSO selectedDialogueGroup = DSIOUtility.LoadAsset<DSDialogueGroupSO>($"Assets/DialogSystem/Dialogues/{dialogueContainer.FileName}/Groups/{selectedDialogueGroupName}", selectedDialogueGroupName);

            dialogueGroupProperty.objectReferenceValue = selectedDialogueGroup;

            DSInspectorUtility.DrawDisabledFields(() => dialogueGroupProperty.DrawPropertyField());

            DSInspectorUtility.DrawSpace();
        }

        private void DrawDialogueArea(List<string> dialogueNames, string dialogueFolderPath)
        {
            DSInspectorUtility.DrawHeader("Dialogue");

            int oldSelectedDialogueIndex = selectedDialogueIndexProperty.intValue;

            DSDialogueSO oldDialogue = (DSDialogueSO)dialogueProperty.objectReferenceValue;

            bool isOldDialogueNull = oldDialogue == null;

            string oldDialogueName = isOldDialogueNull ? "" : oldDialogue.DialogueName;

            UpdateIndexOnNamesListUpdate(dialogueNames, selectedDialogueIndexProperty, oldSelectedDialogueIndex, oldDialogueName, isOldDialogueNull);

            selectedDialogueIndexProperty.intValue = DSInspectorUtility.DrawPopup("Dialogue", selectedDialogueIndexProperty, dialogueNames.ToArray());

            string selectedDialogueName = dialogueNames[selectedDialogueIndexProperty.intValue];

            DSDialogueSO selectedDialogue = DSIOUtility.LoadAsset<DSDialogueSO>(dialogueFolderPath, selectedDialogueName);

            dialogueProperty.objectReferenceValue = selectedDialogue;

            DSInspectorUtility.DrawDisabledFields(() => dialogueProperty.DrawPropertyField());
        }

        private void StopDrawing(string reason, MessageType messageType = MessageType.Info)
        {
            DSInspectorUtility.DrawHelpBox(reason, messageType);

            DSInspectorUtility.DrawSpace();

            DSInspectorUtility.DrawHelpBox("You need to select a Dialogue for this component to work properly at Runtime!", MessageType.Warning);

            serializedObject.ApplyModifiedProperties();
        }

        private void UpdateIndexOnNamesListUpdate(List<string> optionNames, SerializedProperty indexProperty, int oldSelectedPropertyIndex, string oldPropertyName, bool isOldPropertyNull)
        {
            if (isOldPropertyNull)
            {
                indexProperty.intValue = 0;

                return;
            }

            bool oldIndexIsOutOfBoundsOfNamesListCount = oldSelectedPropertyIndex > optionNames.Count - 1;
            bool oldNameIsDifferentThanSelectedName = oldIndexIsOutOfBoundsOfNamesListCount || oldPropertyName != optionNames[oldSelectedPropertyIndex];

            if (oldNameIsDifferentThanSelectedName)
            {
                if (optionNames.Contains(oldPropertyName))
                {
                    indexProperty.intValue = optionNames.IndexOf(oldPropertyName);

                    return;
                }

                indexProperty.intValue = 0;
            }
        }
    }
}
</file>

<file path="DialogueSystem/Inspectors/DSInspector.cs.meta">
fileFormatVersion: 2
guid: eae120845fca4e449ad92ac0ef03e7d3
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="DialogueSystem/SerializableDictionary.cs">
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.Serialization;

public class SerializableDictionary
{

}


/*--------------------------------------------------------------------------------------------------------------------------------------------*/

/* Unity không hỗ trợ trực tiếp việc serialize các Dictionary<TKey, TValue> vào Inspector, vì Dictionary không được Unity hỗ trợ serialization */

/* Do đó, SerializableDictionary<TKey, TValue> là một cách để tạo một dictionary có thể được serialize trong Unity Editor. */

/*--------------------------------------------------------------------------------------------------------------------------------------------*/



[Serializable]
public class SerializableDictionary<TKey, TValue> : SerializableDictionary, IDictionary<TKey, TValue>, ISerializationCallbackReceiver
{
    [SerializeField]
    private List<SerializableKeyValuePair> list = new List<SerializableKeyValuePair>();

    [Serializable]
    public struct SerializableKeyValuePair
    {
        public TKey Key;
        public TValue Value;

        public SerializableKeyValuePair(TKey key, TValue value)
        {
            Key = key;
            Value = value;
        }

        public void SetValue(TValue value)
        {
            Value = value;
        }
    }

    private Dictionary<TKey, uint> KeyPositions => _keyPositions.Value;
    private Lazy<Dictionary<TKey, uint>> _keyPositions;

    public SerializableDictionary()
    {
        _keyPositions = new Lazy<Dictionary<TKey, uint>>(MakeKeyPositions);
    }

    public SerializableDictionary(IDictionary<TKey, TValue> dictionary)
    {
        _keyPositions = new Lazy<Dictionary<TKey, uint>>(MakeKeyPositions);

        if (dictionary == null)
        {
            throw new ArgumentException("The passed dictionary is null.");
        }

        foreach (KeyValuePair<TKey, TValue> pair in dictionary)
        {
            Add(pair.Key, pair.Value);
        }
    }

    private Dictionary<TKey, uint> MakeKeyPositions()
    {
        int numEntries = list.Count;

        Dictionary<TKey, uint> result = new Dictionary<TKey, uint>(numEntries);

        for (int i = 0; i < numEntries; ++i)
        {
            result[list[i].Key] = (uint)i;
        }

        return result;
    }

    public void OnBeforeSerialize()
    {
    }

    public void OnAfterDeserialize()
    {
        // After deserialization, the key positions might be changed
        _keyPositions = new Lazy<Dictionary<TKey, uint>>(MakeKeyPositions);
    }

    #region IDictionary
    public TValue this[TKey key]
    {
        get => list[(int)KeyPositions[key]].Value;
        set
        {
            if (KeyPositions.TryGetValue(key, out uint index))
            {
                list[(int)index].SetValue(value);
            }
            else
            {
                KeyPositions[key] = (uint)list.Count;

                list.Add(new SerializableKeyValuePair(key, value));
            }
        }
    }

    public ICollection<TKey> Keys => list.Select(tuple => tuple.Key).ToArray();
    public ICollection<TValue> Values => list.Select(tuple => tuple.Value).ToArray();

    public void Add(TKey key, TValue value)
    {
        if (KeyPositions.ContainsKey(key))
        {
            throw new ArgumentException("An element with the same key already exists in the dictionary.");
        }
        else
        {
            KeyPositions[key] = (uint)list.Count;

            list.Add(new SerializableKeyValuePair(key, value));
        }
    }

    public bool ContainsKey(TKey key) => KeyPositions.ContainsKey(key);

    public bool Remove(TKey key)
    {
        if (KeyPositions.TryGetValue(key, out uint index))
        {
            Dictionary<TKey, uint> kp = KeyPositions;

            kp.Remove(key);

            list.RemoveAt((int)index);

            int numEntries = list.Count;

            for (uint i = index; i < numEntries; i++)
            {
                kp[list[(int)i].Key] = i;
            }

            return true;
        }

        return false;
    }

    public bool TryGetValue(TKey key, out TValue value)
    {
        if (KeyPositions.TryGetValue(key, out uint index))
        {
            value = list[(int)index].Value;

            return true;
        }

        value = default;

        return false;
    }
    #endregion

    #region ICollection
    public int Count => list.Count;
    public bool IsReadOnly => false;

    public void Add(KeyValuePair<TKey, TValue> kvp) => Add(kvp.Key, kvp.Value);

    public void Clear()
    {
        list.Clear();
        KeyPositions.Clear();
    }

    public bool Contains(KeyValuePair<TKey, TValue> kvp) => KeyPositions.ContainsKey(kvp.Key);

    public void CopyTo(KeyValuePair<TKey, TValue>[] array, int arrayIndex)
    {
        int numKeys = list.Count;

        if (array.Length - arrayIndex < numKeys)
        {
            throw new ArgumentException("arrayIndex");
        }

        for (int i = 0; i < numKeys; ++i, ++arrayIndex)
        {
            SerializableKeyValuePair entry = list[i];

            array[arrayIndex] = new KeyValuePair<TKey, TValue>(entry.Key, entry.Value);
        }
    }

    public bool Remove(KeyValuePair<TKey, TValue> kvp) => Remove(kvp.Key);
    #endregion

    #region IEnumerable
    public IEnumerator<KeyValuePair<TKey, TValue>> GetEnumerator()
    {
        return list.Select(ToKeyValuePair).GetEnumerator();

        KeyValuePair<TKey, TValue> ToKeyValuePair(SerializableKeyValuePair skvp)
        {
            return new KeyValuePair<TKey, TValue>(skvp.Key, skvp.Value);
        }
    }
    IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
    #endregion
}
</file>

<file path="DialogueSystem/SerializableDictionary.cs.meta">
fileFormatVersion: 2
guid: 48ce91ae43b603d42b1ce733156d7afa
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="DialogueSystem/TextUtility.cs">
public static class TextUtility
{
    public static bool IsWhitespace(this char character)
    {
        switch (character)
        {
            case '\u0020':
            case '\u00A0':
            case '\u1680':
            case '\u2000':
            case '\u2001':
            case '\u2002':
            case '\u2003':
            case '\u2004':
            case '\u2005':
            case '\u2006':
            case '\u2007':
            case '\u2008':
            case '\u2009':
            case '\u200A':
            case '\u202F':
            case '\u205F':
            case '\u3000':
            case '\u2028':
            case '\u2029':
            case '\u0009':
            case '\u000A':
            case '\u000B':
            case '\u000C':
            case '\u000D':
            case '\u0085':
                {
                    return true;
                }

            default:
                {
                    return false;
                }
        }
    }

    // While unnecessary for this project, I've used the method seen here: https://stackoverflow.com/a/37368176
    // Benchmarks: https://stackoverflow.com/a/37347881
    public static string RemoveWhitespaces(this string text)
    {
        int textLength = text.Length;

        char[] textCharacters = text.ToCharArray();

        int currentWhitespacelessTextLength = 0;

        for (int currentCharacterIndex = 0; currentCharacterIndex < textLength; ++currentCharacterIndex)
        {
            char currentTextCharacter = textCharacters[currentCharacterIndex];

            if (currentTextCharacter.IsWhitespace())
            {
                continue;
            }

            textCharacters[currentWhitespacelessTextLength++] = currentTextCharacter;
        }

        return new string(textCharacters, 0, currentWhitespacelessTextLength);
    }

    // See here for alternatives: https://stackoverflow.com/questions/3210393/how-do-i-remove-all-non-alphanumeric-characters-from-a-string-except-dash
    public static string RemoveSpecialCharacters(this string text)
    {
        int textLength = text.Length;

        char[] textCharacters = text.ToCharArray();

        int currentWhitespacelessTextLength = 0;

        for (int currentCharacterIndex = 0; currentCharacterIndex < textLength; ++currentCharacterIndex)
        {
            char currentTextCharacter = textCharacters[currentCharacterIndex];

            if (!char.IsLetterOrDigit(currentTextCharacter) && !currentTextCharacter.IsWhitespace())
            {
                continue;
            }

            textCharacters[currentWhitespacelessTextLength++] = currentTextCharacter;
        }

        return new string(textCharacters, 0, currentWhitespacelessTextLength);
    }
}
</file>

<file path="DialogueSystem/TextUtility.cs.meta">
fileFormatVersion: 2
guid: 21b53baefc357474990e5e790a71d6a4
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="DialogueSystem/Ultilities.meta">
fileFormatVersion: 2
guid: 2fd0f2a783c7c7945994908e6e3cbd88
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="DialogueSystem/Ultilities/DSElementsUltilities.cs">
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UIElements;

namespace DS.Ultilities
{
    using Elements;
    using UnityEditor.Experimental.GraphView;

    public static class DSElementsUltilities
    {

        public static Port CreatePort(this DSNode node, string portName = "", Orientation orientation = Orientation.Horizontal, Direction direction = Direction.Output, Port.Capacity capacity = Port.Capacity.Single)
        {
            Port port = node.InstantiatePort(orientation, direction, capacity, typeof(bool));

            port.portName = portName;

            return port;
        }


        public static Button CreateButton(string text, Action onClick = null)
        {
            Button button = new Button(onClick)
            {
                text = text
            };

            return button;
        }

        public static Foldout CreateFoldout(string title, bool collapsed = false)
        {
            Foldout foldout = new Foldout()
            {
                text = title,
                value = !collapsed
            };

            return foldout;
        }

        public static TextField CreateTextField(string value =null, string label = null, EventCallback<ChangeEvent<string>> onValueChanged = null)
        {
            TextField textField = new TextField()
            {
                value = value,
                label = label
            };

            if (onValueChanged != null)
            {
                textField.RegisterCallback(onValueChanged);
            }

            return textField;
        }

        public static TextField CreateTextArea(string value = null, string label = null, EventCallback<ChangeEvent<string>> onValueChanged = null)
        {
            TextField textarea = CreateTextField(value, label, onValueChanged);

            textarea.multiline = true;

            return textarea;
        }
    }

}
</file>

<file path="DialogueSystem/Ultilities/DSElementsUltilities.cs.meta">
fileFormatVersion: 2
guid: f69274ee42da7f744bf2160846813cff
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="DialogueSystem/Ultilities/DSInspectorUltility.cs">
using System;
using UnityEditor;

namespace DS.Utilities
{
    public static class DSInspectorUtility
    {
        public static void DrawDisabledFields(Action action)
        {
            EditorGUI.BeginDisabledGroup(true);

            action.Invoke();

            EditorGUI.EndDisabledGroup();
        }

        public static void DrawHeader(string label)
        {
            EditorGUILayout.LabelField(label, EditorStyles.boldLabel);
        }

        public static void DrawHelpBox(string message, MessageType messageType = MessageType.Info, bool wide = true)
        {
            EditorGUILayout.HelpBox(message, messageType, wide);
        }

        public static int DrawPopup(string label, SerializedProperty selectedIndexProperty, string[] options)
        {
            return EditorGUILayout.Popup(label, selectedIndexProperty.intValue, options);
        }

        public static int DrawPopup(string label, int selectedIndex, string[] options)
        {
            return EditorGUILayout.Popup(label, selectedIndex, options);
        }

        public static bool DrawPropertyField(this SerializedProperty serializedProperty)
        {
            return EditorGUILayout.PropertyField(serializedProperty);
        }

        public static void DrawSpace(int amount = 4)
        {
            EditorGUILayout.Space(amount);
        }
    }
}
</file>

<file path="DialogueSystem/Ultilities/DSInspectorUltility.cs.meta">
fileFormatVersion: 2
guid: 5d9a5d4adaf3ee64c8445d13fa92883a
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="DialogueSystem/Ultilities/DSIOUltility.cs">
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEditor;
using UnityEditor.Experimental.GraphView;
using UnityEngine;

namespace DS.Utilities
{
    using Data;
    using Data.Save;
    using DS.windows;
    using Elements;
    using ScriptableObjects;
    using Windows;

    public static class DSIOUtility
    {
        private static DSGraphView graphView;

        private static string graphFileName;
        private static string containerFolderPath;

        private static List<DSNode> nodes;
        private static List<DSGroup> groups;

        private static Dictionary<string, DSDialogueGroupSO> createdDialogueGroups;
        private static Dictionary<string, DSDialogueSO> createdDialogues;

        private static Dictionary<string, DSGroup> loadedGroups;
        private static Dictionary<string, DSNode> loadedNodes;

        public static void Initialize(DSGraphView dsGraphView, string graphName)
        {
            graphView = dsGraphView;

            graphFileName = graphName;
            containerFolderPath = $"Assets/DialogSystem/Dialogues/{graphName}";

            nodes = new List<DSNode>();
            groups = new List<DSGroup>();

            createdDialogueGroups = new Dictionary<string, DSDialogueGroupSO>();
            createdDialogues = new Dictionary<string, DSDialogueSO>();

            loadedGroups = new Dictionary<string, DSGroup>();
            loadedNodes = new Dictionary<string, DSNode>();
        }

        public static void Save()
        {
            CreateDefaultFolders();

            GetElementsFromGraphView();

            DSGraphSaveDataSO graphData = CreateAsset<DSGraphSaveDataSO>("Assets/Script/DialogueSystem/Graphs", $"{graphFileName}Graph");

            graphData.Initialize(graphFileName);

            DSDialogueContainerSO dialogueContainer = CreateAsset<DSDialogueContainerSO>(containerFolderPath, graphFileName);

            dialogueContainer.Initialize(graphFileName);

            SaveGroups(graphData, dialogueContainer);
            SaveNodes(graphData, dialogueContainer);

            SaveAsset(graphData);
            SaveAsset(dialogueContainer);
        }

        private static void SaveGroups(DSGraphSaveDataSO graphData, DSDialogueContainerSO dialogueContainer)
        {
            List<string> groupNames = new List<string>();

            foreach (DSGroup group in groups)
            {
                SaveGroupToGraph(group, graphData);
                SaveGroupToScriptableObject(group, dialogueContainer);

                groupNames.Add(group.title);
            }

            UpdateOldGroups(groupNames, graphData);
        }

        private static void SaveGroupToGraph(DSGroup group, DSGraphSaveDataSO graphData)
        {
            DSGroupSaveData groupData = new DSGroupSaveData()
            {
                ID = group.ID,
                Name = group.title,
                Position = group.GetPosition().position
            };

            graphData.Groups.Add(groupData);
        }

        private static void SaveGroupToScriptableObject(DSGroup group, DSDialogueContainerSO dialogueContainer)
        {
            string groupName = group.title;

            CreateFolder($"{containerFolderPath}/Groups", groupName);
            CreateFolder($"{containerFolderPath}/Groups/{groupName}", "Dialogues");

            DSDialogueGroupSO dialogueGroup = CreateAsset<DSDialogueGroupSO>($"{containerFolderPath}/Groups/{groupName}", groupName);

            dialogueGroup.Initialize(groupName);

            createdDialogueGroups.Add(group.ID, dialogueGroup);

            dialogueContainer.DialogueGroups.Add(dialogueGroup, new List<DSDialogueSO>());

            SaveAsset(dialogueGroup);
        }

        private static void UpdateOldGroups(List<string> currentGroupNames, DSGraphSaveDataSO graphData)
        {
            if (graphData.OldGroupNames != null && graphData.OldGroupNames.Count != 0)
            {
                List<string> groupsToRemove = graphData.OldGroupNames.Except(currentGroupNames).ToList();

                foreach (string groupToRemove in groupsToRemove)
                {
                    RemoveFolder($"{containerFolderPath}/Groups/{groupToRemove}");
                }
            }

            graphData.OldGroupNames = new List<string>(currentGroupNames);
        }

        private static void SaveNodes(DSGraphSaveDataSO graphData, DSDialogueContainerSO dialogueContainer)
        {
            SerializableDictionary<string, List<string>> groupedNodeNames = new SerializableDictionary<string, List<string>>();
            List<string> ungroupedNodeNames = new List<string>();

            foreach (DSNode node in nodes)
            {
                SaveNodeToGraph(node, graphData);
                SaveNodeToScriptableObject(node, dialogueContainer);

                if (node.Group != null)
                {
                    groupedNodeNames.AddItem(node.Group.title, node.DialogName);

                    continue;
                }

                ungroupedNodeNames.Add(node.DialogName);
            }

            UpdateDialoguesChoicesConnections();

            UpdateOldGroupedNodes(groupedNodeNames, graphData);
            UpdateOldUngroupedNodes(ungroupedNodeNames, graphData);
        }

        private static void SaveNodeToGraph(DSNode node, DSGraphSaveDataSO graphData)
        {
            List<DSChoiceSaveData> choices = CloneNodeChoices(node.Choices);

            DSNodeSaveData nodeData = new DSNodeSaveData()
            {
                ID = node.ID,
                Name = node.DialogName,
                Choices = choices,
                Text = node.Text,
                GroupID = node.Group?.ID,
                DialogueType = node.DialogueType,
                Position = node.GetPosition().position
            };

            graphData.Nodes.Add(nodeData);
        }

        private static void SaveNodeToScriptableObject(DSNode node, DSDialogueContainerSO dialogueContainer)
        {
            DSDialogueSO dialogue;

            if (node.Group != null)
            {
                dialogue = CreateAsset<DSDialogueSO>($"{containerFolderPath}/Groups/{node.Group.title}/Dialogues", node.DialogName);

                dialogueContainer.DialogueGroups.AddItem(createdDialogueGroups[node.Group.ID], dialogue);
            }
            else
            {
                dialogue = CreateAsset<DSDialogueSO>($"{containerFolderPath}/Global/Dialogues", node.DialogName);

                dialogueContainer.UngroupedDialogues.Add(dialogue);
            }

            dialogue.Initialize(
                node.DialogName,
                node.Text,
                ConvertNodeChoicesToDialogueChoices(node.Choices),
                node.DialogueType,
                node.IsStartingNode(),
                node.ExecutedFunction
            );

            createdDialogues.Add(node.ID, dialogue);

            SaveAsset(dialogue);
        }

        private static List<DSDialogueChoiceData> ConvertNodeChoicesToDialogueChoices(List<DSChoiceSaveData> nodeChoices)
        {
            List<DSDialogueChoiceData> dialogueChoices = new List<DSDialogueChoiceData>();

            foreach (DSChoiceSaveData nodeChoice in nodeChoices)
            {
                DSDialogueChoiceData choiceData = new DSDialogueChoiceData()
                {
                    Text = nodeChoice.Text,
                    ExecutedFunction = nodeChoice.ExecutedFunction
                };

                dialogueChoices.Add(choiceData);
            }

            return dialogueChoices;
        }

        private static void UpdateDialoguesChoicesConnections()
        {
            foreach (DSNode node in nodes)
            {
                DSDialogueSO dialogue = createdDialogues[node.ID];

                for (int choiceIndex = 0; choiceIndex < node.Choices.Count; ++choiceIndex)
                {
                    DSChoiceSaveData nodeChoice = node.Choices[choiceIndex];

                    if (string.IsNullOrEmpty(nodeChoice.NodeID))
                    {
                        continue;
                    }

                    dialogue.Choices[choiceIndex].NextDialogue = createdDialogues[nodeChoice.NodeID];

                    SaveAsset(dialogue);
                }
            }
        }

        private static void UpdateOldGroupedNodes(SerializableDictionary<string, List<string>> currentGroupedNodeNames, DSGraphSaveDataSO graphData)
        {
            if (graphData.OldGroupedNodeNames != null && graphData.OldGroupedNodeNames.Count != 0)
            {
                foreach (KeyValuePair<string, List<string>> oldGroupedNode in graphData.OldGroupedNodeNames)
                {
                    List<string> nodesToRemove = new List<string>();

                    if (currentGroupedNodeNames.ContainsKey(oldGroupedNode.Key))
                    {
                        nodesToRemove = oldGroupedNode.Value.Except(currentGroupedNodeNames[oldGroupedNode.Key]).ToList();
                    }

                    foreach (string nodeToRemove in nodesToRemove)
                    {
                        RemoveAsset($"{containerFolderPath}/Groups/{oldGroupedNode.Key}/Dialogues", nodeToRemove);
                    }
                }
            }

            graphData.OldGroupedNodeNames = new SerializableDictionary<string, List<string>>(currentGroupedNodeNames);
        }

        private static void UpdateOldUngroupedNodes(List<string> currentUngroupedNodeNames, DSGraphSaveDataSO graphData)
        {
            if (graphData.OldUngroupedNodeNames != null && graphData.OldUngroupedNodeNames.Count != 0)
            {
                List<string> nodesToRemove = graphData.OldUngroupedNodeNames.Except(currentUngroupedNodeNames).ToList();

                foreach (string nodeToRemove in nodesToRemove)
                {
                    RemoveAsset($"{containerFolderPath}/Global/Dialogues", nodeToRemove);
                }
            }

            graphData.OldUngroupedNodeNames = new List<string>(currentUngroupedNodeNames);
        }

        public static void Load()
        {
            DSGraphSaveDataSO graphData = LoadAsset<DSGraphSaveDataSO>("Assets/Script/DialogueSystem/Graphs", graphFileName);

            if (graphData == null)
            {
                EditorUtility.DisplayDialog(
                    "Could not find the file!",
                    "The file at the following path could not be found:\n\n" +
                    $"\"Assets/Editor/DialogueSystem/Graphs/{graphFileName}\".\n\n" +
                    "Make sure you chose the right file and it's placed at the folder path mentioned above.",
                    "Thanks!"
                );

                return;
            }

           DSEditorWindow.UpdateFileName(graphData.FileName);

            LoadGroups(graphData.Groups);
        LoadNodes(graphData.Nodes);
            LoadNodesConnections();
        }

        private static void LoadGroups(List<DSGroupSaveData> groups)
        {
            foreach (DSGroupSaveData groupData in groups)
            {
                DSGroup group = graphView.CreateGroup(groupData.Name, groupData.Position);

                group.ID = groupData.ID;

                loadedGroups.Add(group.ID, group);
            }
        }

      
        private static void LoadNodes(List<DSNodeSaveData> nodes)
        {
            foreach (DSNodeSaveData nodeData in nodes)
            {
                List<DSChoiceSaveData> choices = CloneNodeChoices(nodeData.Choices);

                DSNode node = graphView.CreateNode(nodeData.Name, nodeData.DialogueType, nodeData.Position, false);

                node.ID = nodeData.ID;
                node.Choices = choices;
                node.Text = nodeData.Text;

                node.Draw();

                graphView.AddElement(node);

                loadedNodes.Add(node.ID, node);

                if (string.IsNullOrEmpty(nodeData.GroupID))
                {
                    continue;
                }

                DSGroup group = loadedGroups[nodeData.GroupID];

                node.Group = group;

                group.AddElement(node);
            }
        }
      

        private static void LoadNodesConnections()
        {
            foreach (KeyValuePair<string, DSNode> loadedNode in loadedNodes)
            {
                foreach (Port choicePort in loadedNode.Value.outputContainer.Children())
                {
                    DSChoiceSaveData choiceData = (DSChoiceSaveData)choicePort.userData;

                    if (string.IsNullOrEmpty(choiceData.NodeID))
                    {
                        continue;
                    }

                    DSNode nextNode = loadedNodes[choiceData.NodeID];

                    Port nextNodeInputPort = (Port)nextNode.inputContainer.Children().First();

                    Edge edge = choicePort.ConnectTo(nextNodeInputPort);

                    graphView.AddElement(edge);

                    loadedNode.Value.RefreshPorts();
                }
            }
        }

        private static void CreateDefaultFolders()
        {
            CreateFolder("Assets/Script/DialogueSystem", "Graphs");

            CreateFolder("Assets", "DialogSystem");
            CreateFolder("Assets/DialogSystem", "Dialogues");

            CreateFolder("Assets/DialogSystem/Dialogues", graphFileName);
            CreateFolder(containerFolderPath, "Global");
            CreateFolder(containerFolderPath, "Groups");
            CreateFolder($"{containerFolderPath}/Global", "Dialogues");
        }

        private static void GetElementsFromGraphView()
        {
            Type groupType = typeof(DSGroup);

            graphView.graphElements.ForEach(graphElement =>
            {
                if (graphElement is DSNode node)
                {
                    nodes.Add(node);

                    return;
                }

                if (graphElement.GetType() == groupType)
                {
                    DSGroup group = (DSGroup)graphElement;

                    groups.Add(group);

                    return;
                }
            });
        }

        public static void CreateFolder(string parentFolderPath, string newFolderName)
        {
            if (AssetDatabase.IsValidFolder($"{parentFolderPath}/{newFolderName}"))
            {
                return;
            }

            AssetDatabase.CreateFolder(parentFolderPath, newFolderName);
        }

        public static void RemoveFolder(string path)
        {
            FileUtil.DeleteFileOrDirectory($"{path}.meta");
            FileUtil.DeleteFileOrDirectory($"{path}/");
        }

        public static T CreateAsset<T>(string path, string assetName) where T : ScriptableObject
        {
            string fullPath = $"{path}/{assetName}.asset";

            T asset = LoadAsset<T>(path, assetName);

            if (asset == null)
            {
                asset = ScriptableObject.CreateInstance<T>();

                AssetDatabase.CreateAsset(asset, fullPath);
            }

            return asset;
        }

        public static T LoadAsset<T>(string path, string assetName) where T : ScriptableObject
        {
            string fullPath = $"{path}/{assetName}.asset";

            return AssetDatabase.LoadAssetAtPath<T>(fullPath);
        }

        public static void SaveAsset(UnityEngine.Object asset)
        {
            EditorUtility.SetDirty(asset);

            AssetDatabase.SaveAssets();
            AssetDatabase.Refresh();
        }

        public static void RemoveAsset(string path, string assetName)
        {
            AssetDatabase.DeleteAsset($"{path}/{assetName}.asset");
        }

        private static List<DSChoiceSaveData> CloneNodeChoices(List<DSChoiceSaveData> nodeChoices)
        {
            List<DSChoiceSaveData> choices = new List<DSChoiceSaveData>();

            foreach (DSChoiceSaveData choice in nodeChoices)
            {
                DSChoiceSaveData choiceData = new DSChoiceSaveData()
                {
                    Text = choice.Text,
                    NodeID = choice.NodeID
                };

                choices.Add(choiceData);
            }

            return choices;
        }
    }
}
</file>

<file path="DialogueSystem/Ultilities/DSIOUltility.cs.meta">
fileFormatVersion: 2
guid: 8bf9cb7da488cf241ac450e7cee80c4a
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="DialogueSystem/Ultilities/DSStylesUltilities.cs">
using System.Collections;
using System.Collections.Generic;
using UnityEditor;
using UnityEngine;
using UnityEngine.UIElements;


namespace DS.Ultilities 
{
    public static class DSStylesUltilities
    {

        public static VisualElement AddClasses(this VisualElement element, params string[] classNames)
        {
            foreach (string className in classNames)
            {
                element.AddToClassList(className);
            }

            return element;
        }


        public static VisualElement AddStyleSheets(this VisualElement element, params string[] styleSheetNames)
        {
            foreach (string styleSheetName in styleSheetNames)
            {
                StyleSheet styleSheet = (StyleSheet)EditorGUIUtility.Load(styleSheetName);

                element.styleSheets.Add(styleSheet);
            }

            return element;
        }
    }
}
</file>

<file path="DialogueSystem/Ultilities/DSStylesUltilities.cs.meta">
fileFormatVersion: 2
guid: e5611cb5c23fe9345babd0618149f061
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="DialogueSystem/Windows.meta">
fileFormatVersion: 2
guid: e41acef9ba58cb1498ea9c67eacc0bc4
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="DialogueSystem/Windows/DSEditorWindow.cs">
using UnityEditor;
using UnityEngine;
using UnityEngine.UIElements;
using System.IO;

namespace DS.windows
{
    using DS.Utilities;
    using System;
    using Ultilities;
    using UnityEditor.Experimental.GraphView;
    using UnityEditor.UIElements;

    #region Vì sao các phương thức trong DSGraphView được sử dụng một cách liên tục 

    /*--------------------------------------------------------------------------------------------------------------------*/

    /*  rootVisualElement là gốc của hệ thống UI trong EditorWindow, đóng vai trò như một container chứa tất cả các thành phần UI. */

    /*  graphView (là một instance của DSGraphView) được thêm vào rootVisualElement, khiến nó trở thành một phần của giao diện và duy trì trạng thái trong suốt vòng đời của cửa sổ.

       Điều đó giúp chúng ta sử dụng các phương thức trong DSGraphView một cách liên tục */

    /*--------------------------------------------------------------------------------------------------------------------*/

    #endregion

    #region Vì sao DSGraphView vẫn tồn tại?

    /*--------------------------------------------------------------------------------------------------------------------*/

    /*  🔥 Vì sao DSGraphView vẫn tồn tại? */

    /*  rootVisualElement là một phần của Unity UI System, hoạt động độc lập với vòng đời của script. */

    /*  Khi cửa sổ vẫn mở, rootVisualElement giữ nguyên các phần tử bên trong nó, nghĩa là DSGraphView vẫn tồn tại và có thể phản hồi sự kiện. */

    /*  Chỉ khi đóng cửa sổ, Unity reload script, hoặc thay đổi trạng thái Play, OnEnable() mới được gọi lại và DSGraphView mới được tạo lại. */

    /*--------------------------------------------------------------------------------------------------------------------*/

    #endregion

    public class DSEditorWindow : EditorWindow
    {
        private DSGraphView graphView;

        private readonly string defaultFileName = "DialogFileName";

        private static TextField filenameTextField;

        private Button saveButton;

        private Button miniMapButton;

        [SerializeField]

        StyleSheet style;

        [MenuItem("Window/DS/Dialog Graph")]

        public static void ShowExample()
        {
             GetWindow<DSEditorWindow>("Dialog Graph");
       
        }

      private void OnEnable()
        {
            AddGraphView();

            AddToolBar();

            AddStyles();
        }

        #region Các phương thức Add

        private void AddGraphView()
        {
            graphView = new DSGraphView(this);

            graphView.StretchToParentSize();

            rootVisualElement.Add(graphView);
        }

        private void AddToolBar()
        {
            Toolbar toolbar = new Toolbar();

            /*Nếu muốn có WhiteSpaces cho ToolBars thì chỉ cần bỏ callback đi là xong*/
            filenameTextField = DSElementsUltilities.CreateTextField(defaultFileName, "File name:", callback =>
            {
                filenameTextField.value = callback.newValue.RemoveWhitespaces().RemoveSpecialCharacters();    
            });


            saveButton = DSElementsUltilities.CreateButton("Save", () => Save());

            Button loadButton = DSElementsUltilities.CreateButton("Load", () => Load());

            Button clearButton = DSElementsUltilities.CreateButton("Clear", () => Clear());

            Button resetButton = DSElementsUltilities.CreateButton("Reset", () => ResetGraph());

            miniMapButton = DSElementsUltilities.CreateButton("Minimap", () => ToggleMiniMap());

            toolbar.Add(filenameTextField);

            toolbar.Add(saveButton);

            toolbar.Add(clearButton);

            toolbar.Add(loadButton);

            toolbar.Add(resetButton);

            toolbar.Add(miniMapButton);

            toolbar.AddStyleSheets("DialogSystem/DSToolBarStyle.uss");

            rootVisualElement.Add(toolbar);
        }

      

        private void AddStyles()
        {
            rootVisualElement.AddStyleSheets("DialogSystem/DSVariables.uss");
           

        }

        #endregion

        #region Các phương thức Ultility

        public void EnableSaving()
        {
            saveButton.SetEnabled(true);
        }

        public void DisableSaving()
        {
            saveButton.SetEnabled(false);
        }

        #endregion


        private void Save()
        {
            if (string.IsNullOrEmpty(filenameTextField.value))
            {
                EditorUtility.DisplayDialog("Invalid file name.", "Please ensure the file name you've typed in is valid.", "Roger!");
                return;
            }

            DSIOUtility.Initialize(graphView, filenameTextField.value);
            DSIOUtility.Save();
        }

        private void Clear()
        {
            graphView.ClearGraph();
        }

        private void Load()
        {
            string filePath = EditorUtility.OpenFilePanel("Dialogue Graphs", "Assets/Editor/DialogueSystem/Graphs", "asset");

            if (string.IsNullOrEmpty(filePath))
            {
                return;
            }

            Clear();

            DSIOUtility.Initialize(graphView, Path.GetFileNameWithoutExtension(filePath));
            DSIOUtility.Load();
        }

        private void ResetGraph()
        {
            Clear();

            UpdateFileName(defaultFileName);
        }

        public static void UpdateFileName(string newFileName)
        {
            filenameTextField.value = newFileName;
        }

        private void ToggleMiniMap()
        {
            graphView.ToggleMiniMap();

            miniMapButton.ToggleInClassList("ds-toolbar__button__selected");
        }

    }
}
</file>

<file path="DialogueSystem/Windows/DSEditorWindow.cs.meta">
fileFormatVersion: 2
guid: 2e1165c7d7cda4e4cac88486d25207f3
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="DialogueSystem/Windows/DSGraphView.cs">
using DS.Elements;
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEditor;
using UnityEditor.Experimental.GraphView;
using UnityEngine;
using UnityEngine.UIElements;

namespace DS.windows
{
    using System;
    using DS.Windows;
    using Data.Error;
    using Enumerations;
    using Ultilities;
    using UnityEngine.Rendering;
    using static Unity.Burst.Intrinsics.X86.Avx;
    using DS.Data.Save;

    public class DSGraphView : GraphView
    {
        private DSEditorWindow editorWindow;

        private DSSearchWindow searchWindow;

        #region Định nghĩa

        /*--------------------------------------------------------------------------------------------------------------------------------------------*/

        /*ungroupedNodes là một dictionary dùng để chứa các Nodes giống nhau bên ngoài Group*/

        /*groupedNodes là một dictionary dùng để chứa các Nodes giống nhau bên trong Group*/

        /*groups là một dictionary dùng để chứa các Group giống nhau*/

        /*3 Dictionary trên giúp chúng ta phát hiện ra được tên Nodes và Group nào đang trùng nhau*/

        /*--------------------------------------------------------------------------------------------------------------------------------------------*/

        #endregion

        private SerializableDictionary<string, DSNodeErrorData> ungroupedNodes;

        private SerializableDictionary<string, DSGroupErrorData> groups;

        private SerializableDictionary<Group, SerializableDictionary<string, DSNodeErrorData>> groupedNodes;

        private int nameErrorAmount;

        private MiniMap miniMap;


        public int NameErrorAmount
        {
            get
            {
                return nameErrorAmount;
            }

            set
            {
                nameErrorAmount = value;

                if (nameErrorAmount == 0)
                {
                    editorWindow.EnableSaving();
                }

                if (nameErrorAmount == 1)
                {
                    editorWindow.DisableSaving();
                }
            }
        }

       public DSGraphView(DSEditorWindow dSEditorWindow)
        {
            editorWindow = dSEditorWindow;

            ungroupedNodes = new SerializableDictionary<string, DSNodeErrorData>();

            groups = new SerializableDictionary<string, DSGroupErrorData>();

            groupedNodes = new SerializableDictionary<Group, SerializableDictionary<string, DSNodeErrorData>>();

            AddManipulator();

            AddSearchWindow();

            AddMiniMap();

            AddGridBackGround();

            OnElementDeleted();

            OngroupElementsAdded();

            OngroupElementsRemoved();

            OnGroupRenamed();

            OnGraphViewChanged();

            AddStyles();

            AddMiniMapStyles();
        }


        #region Override Method
        public override List<Port> GetCompatiblePorts(Port startPort, NodeAdapter nodeAdapter)
        {
            List<Port> compatiblePorts = new List<Port>();


            /*UQueryState là một dạng truy vấn giúp tìm kiếm và lọc các phần tử trong UI (các VisualElement)*/
            ports.ForEach(port =>
            {
                if(startPort == port)
                {
                    return;
                }
                if (startPort.node == port.node)
                {
                    return;
                }
                if (startPort.direction == port.direction)
                {
                    return;
                }

                compatiblePorts.Add(port);
            });
            return compatiblePorts;
        }
        #endregion


        
        public DSNode CreateNode(string nodeName, DSDialogType DialogueType,Vector2 position, bool shoulDraw = true)
        {

            /*--------------------------------------------------------------------------------------------------------------------------------------------*/

            /*Hãy nhớ Type trong C# không phải là nội dung của class mà là metadata (siêu dữ liệu) về class đó. Nó chứa thông tin như:

             - Tên class
             - Namespace
             -  Assembly chứa class
             -  Class cha (Base Type)
             - Các phương thức, thuộc tính, constructor, interface mà class đó kế thừa
            */

           /*--------------------------------------------------------------------------------------------------------------------------------------------*/


            Type nodetype = Type.GetType($"DS.Elements.DS{DialogueType}Node");

            /*Activator.CreateInstance yêu cầu kiểu dữ liệu là Type */
            DSNode node =(DSNode) Activator.CreateInstance(nodetype); 

            node.Initialize(nodeName, this, position);

            if(shoulDraw)
            {
                node.Draw();
            }

  

            AddUnGroupNode(node);

            return node;
           
        }
  
        private void AddGridBackGround()
        {
            GridBackground gridBackground = new GridBackground();

            gridBackground.StretchToParentSize();

            Insert(0, gridBackground);  
        }
        
        
        private void AddStyles()
        {
            this.AddStyleSheets(
                "DialogSystem/DSGraphViewStyles.uss",
                "DialogSystem/DSNodeStyles.uss"
                );
           

        }
     

        private void AddManipulator()
        {
            SetupZoom(ContentZoomer.DefaultMinScale, ContentZoomer.DefaultMaxScale);
            this.AddManipulator(new ContentDragger());
            this.AddManipulator(new SelectionDragger());
            this.AddManipulator(new RectangleSelector());
            
            this.AddManipulator(CreateNodeContextualMenu("Add Node (Single Choice)", DSDialogType.SingleChoice));
            this.AddManipulator(CreateNodeContextualMenu("Add Node (Multiple Choice)", DSDialogType.MultipleChoice));

            this.AddManipulator(CreateGroupContextualMenu());


        }

        private IManipulator CreateNodeContextualMenu(string actionTitle, DSDialogType DialogueType)
        {
            ContextualMenuManipulator contextualMenuManipulator = new ContextualMenuManipulator(
                   menuEvent => menuEvent.menu.AppendAction(actionTitle, actionEvent => AddElement(CreateNode("DialogueName", DialogueType, GetLocalMousePosition(actionEvent.eventInfo.localMousePosition))))
                );  

            return contextualMenuManipulator;
        }


        private IManipulator CreateGroupContextualMenu()
        {
            ContextualMenuManipulator contextualMenuManipulator = new ContextualMenuManipulator(
                   menuEvent => menuEvent.menu.AppendAction("Add Group", actionEvent => AddElement(CreateGroup("Dialog Group", GetLocalMousePosition(actionEvent.eventInfo.localMousePosition))))
                );

            return contextualMenuManipulator;
        }

        public DSGroup CreateGroup(string title, Vector2 localMousePosition)
        {
            DSGroup group = new DSGroup(title, localMousePosition);

            AddGroup(group);

            #region Vấn đề mã A-1 : Lí do vì sao phải thêm dòng lệnh AddElement(group);
            /*--------------------------------------------------------------------------------------------------------------------------------------------*/

            /*Lí do vì sao phải thêm dòng lệnh AddElement(group); */

            /* Phân tích 
            Trong phương thức CreateGroup, bạn đang lặp qua selection để thêm các Node được chọn vào Group.Tuy nhiên, vấn đề nằm ở chỗ Group chưa được thêm vào GraphView trước khi các Node được thêm vào nó.

            Cụ thể, bạn đang làm theo thứ tự sau:

            1.Tạo Group mới

            2.Duyệt qua danh sách các Node được chọn(selection)

            3.Thêm từng Node vào Group

            Nhưng vấn đề là GraphView chưa nhận biết Group này, vì nó chưa được chính thức thêm vào. Điều này dẫn đến việc:

            GraphView chưa "lắng nghe" sự kiện của Group, do đó nó không gọi các callback cần thiết để chuyển đổi Node từ "ungrouped" sang "grouped".

            Khi bạn gọi group.AddElement(node), GraphView không nhận biết Group này nên nó không kích hoạt các sự kiện cần thiết để cập nhật groupedNodes.
            */

            /*--------------------------------------------------------------------------------------------------------------------------------------------*/

            #endregion
       
            #region Câu hỏi về vấn đề mã A-1: Chẳng phải group đã được cho vào GraphView thông qua IManipulator hay sao

            /*--------------------------------------------------------------------------------------------------------------------------------------------*/

            /* Đúng là trong phương thức CreateGroupContextualMenu, bạn đã thêm Group vào GraphView bằng cách gọi AddElement(CreateGroup(...)). 
             
               Điều đó có nghĩa là Group thực sự sẽ được thêm vào GraphView sau khi CreateGroup kết thúc.

               Tuy nhiên, vấn đề nằm ở thứ tự thực thi của sự kiện và cách GraphView xử lý các callback.

           Giải thích sâu hơn 

               1. Khi nào Group thực sự được thêm vào GraphView?

               Khi bạn gọi CreateGroup(...), phương thức này chỉ tạo ra Group và thêm các Node vào nó.

               Sau khi CreateGroup kết thúc, phương thức CreateGroupContextualMenu sẽ gọi AddElement(group).

               ⚠️ Nhưng tại thời điểm vòng lặp foreach trong CreateGroup chạy, Group vẫn chưa được GraphView nhận diện.

               GraphView không "nghe" sự kiện thêm Node vào Group, vì nó chưa biết đến sự tồn tại của Group.

               Callback elementsAddedToGroup chỉ được kích hoạt nếu Group đã là một phần của GraphView trước khi các Node được thêm vào.

               2. Điều gì sẽ xảy ra nếu Group chưa có trong GraphView khi thêm Node?
  
               Khi bạn gọi group.AddElement(node), Group chưa có trong GraphView, nên callback elementsAddedToGroup không được gọi.

               Điều này khiến Node không được di chuyển từ ungroupedNodes sang groupedNodes, vì sự kiện elementsAddedToGroup chưa được kích hoạt.


            /*--------------------------------------------------------------------------------------------------------------------------------------------*/

            #endregion

            AddElement(group);

            foreach(GraphElement graphElement in selection)
            {
                if(! (graphElement is DSNode))
                {
                    continue;
                }

                DSNode node = (DSNode) graphElement;

                group.AddElement(node);
            }
           
            return group;   
        }
   
        private void AddSearchWindow()
        {
            if(searchWindow == null)
            {
                searchWindow = ScriptableObject.CreateInstance<DSSearchWindow>();                  
            }

            searchWindow.Initialize(this);

            nodeCreationRequest = context => SearchWindow.Open(new SearchWindowContext(context.screenMousePosition), searchWindow); 
            
        }

        public Vector2 GetLocalMousePosition(Vector2 mousePosition, bool isSearchWindow = false)
        {
            Vector2 wordMousePosition = mousePosition;

            if(isSearchWindow)
            {
                wordMousePosition -= editorWindow.position.position;
            }

            Vector2 localMousePosition = contentViewContainer.WorldToLocal(wordMousePosition);

            return localMousePosition;
        }

        public void ClearGraph()
        {
            graphElements.ForEach(graphElement => RemoveElement(graphElement));

            groups.Clear();
            groupedNodes.Clear();
            ungroupedNodes.Clear();

            NameErrorAmount = 0;
        }

        private void AddMiniMap()
        {
            miniMap = new MiniMap()
            {
                anchored = true
            };

            miniMap.SetPosition(new Rect(15, 50, 200, 180));

            Add(miniMap);

            miniMap.visible = false;
        }

        private void AddMiniMapStyles()
        {
            StyleColor backgroundColor = new StyleColor(new Color32(29, 29, 30, 255));
            StyleColor borderColor = new StyleColor(new Color32(51, 51, 51, 255));

            miniMap.style.backgroundColor = backgroundColor;
            miniMap.style.borderTopColor = borderColor;
            miniMap.style.borderRightColor = borderColor;
            miniMap.style.borderBottomColor = borderColor;
            miniMap.style.borderLeftColor = borderColor;
        }

        public void ToggleMiniMap()
        {
            miniMap.visible = !miniMap.visible;
        }


        #region Các phương thức lặp lại 

        public void AddUnGroupNode(DSNode node)
        {
            string nodename = node.DialogName.ToLower();

            if (!ungroupedNodes.ContainsKey(nodename))
            {
                DSNodeErrorData nodeErrorData = new DSNodeErrorData();

                nodeErrorData.Nodes.Add(node);

                ungroupedNodes.Add(nodename, nodeErrorData);

                return;
            }

            List<DSNode> ungroupNodesList = ungroupedNodes[nodename].Nodes;

            ungroupNodesList.Add(node);

            Color errorcolor = ungroupedNodes[nodename].ErrorData.Color;

            node.SetErrorStyle(errorcolor);

            if (ungroupNodesList.Count == 2)
            {
                ++nameErrorAmount;

                ungroupNodesList[0].SetErrorStyle(errorcolor);
            }

        }

        public void RemoveUnGroupNode(DSNode node)
        {
            string nodename = node.DialogName.ToLower();



            List<DSNode> ungroupNodesList = ungroupedNodes[nodename].Nodes;

            ungroupNodesList.Remove(node);

            node.ResetStyle();

            if (ungroupNodesList.Count == 1)
            {
                --nameErrorAmount;

                ungroupNodesList[0].ResetStyle();

                return;
            }

            if (ungroupNodesList.Count == 0)
            {
                ungroupedNodes.Remove(nodename);
            }
        }

        public void AddGroupedNode(DSNode node, DSGroup group)
        {
            string nodename = node.DialogName.ToLower();

            node.Group = group;

            if (!groupedNodes.ContainsKey(group))
            {
                groupedNodes.Add(group, new SerializableDictionary<string, DSNodeErrorData>());
            }

            if (!groupedNodes[group].ContainsKey(nodename))
            {
                DSNodeErrorData nodeErrorData = new DSNodeErrorData();

                nodeErrorData.Nodes.Add(node);

                groupedNodes[group].Add(nodename, nodeErrorData);

                return;
            }

            List<DSNode> groupNodesList = groupedNodes[group][nodename].Nodes;

            groupNodesList.Add(node);

            Color errorColor = groupedNodes[group][nodename].ErrorData.Color;

            node.SetErrorStyle(errorColor);

            if (groupNodesList.Count == 2)
            {
                ++nameErrorAmount;

                groupNodesList[0].SetErrorStyle(errorColor);
            }
        }

        public void RemoveGroupedNode(DSNode node, Group group)
        {
            string nodeName = node.DialogName.ToLower();

            node.Group = null;

            List<DSNode> groupNodesList = groupedNodes[group][nodeName].Nodes;

            groupNodesList.Remove(node);

            node.ResetStyle();

            if (groupNodesList.Count == 1)
            {
                --nameErrorAmount;

                groupNodesList[0].ResetStyle();

                return;
            }

            if (groupNodesList.Count == 0)
            {
                groupedNodes[group].Remove(nodeName);

                if (groupedNodes[group].Count == 0)
                {
                    groupedNodes.Remove(group);
                }
            }
        }

        private void AddGroup(DSGroup group)
        {
            string groupName = group.title.ToLower();

            if (!groups.ContainsKey(groupName))
            {
                DSGroupErrorData groupErrorData = new DSGroupErrorData();

                groupErrorData.Groups.Add(group);

                groups.Add(groupName, groupErrorData);

                return;
            }

            List<DSGroup> grouplist = groups[groupName].Groups;

            grouplist.Add(group);

            Color errorColor = groups[groupName].DSErrorData.Color;

            group.SetErrorStyle(errorColor);

            if (grouplist.Count == 2)
            {
                ++nameErrorAmount;

                grouplist[0].SetErrorStyle(errorColor);
            }
        }

        private void RemoveGroup(DSGroup group)
        {
            string oldGroupName = group.oldtitle.ToLower();

            List<DSGroup> grouplist = groups[oldGroupName].Groups;

            groups[oldGroupName].Groups.Remove(group);

            group.ResetStyle();

            if (grouplist.Count == 1)
            {
                --nameErrorAmount;

                grouplist[0].ResetStyle();

                return;
            }

            if (grouplist.Count == 1)
            {
                groups.Remove(oldGroupName);
            }
        }

        #endregion

        #region CallBacks
        private void OnElementDeleted()
        {
            deleteSelection = (operationName, askUser) =>
            {

                #region  Dòng "Type groupType = typeof(DSGroup);" có ý nghĩa gì ?

                /*--------------------------------------------------------------------------------------------------------------------------------------------*/

                /*
                 
                Dòng Type groupType = typeof(DSGroup); có vai trò lưu lại thông tin kiểu của DSGroup để dùng cho việc so sánh tại runtime, nhằm xác định phần tử trong selection có đúng là một nhóm (group) hay không.

                Các Type còn lại cũng tương tự như vậy

                */
                /*--------------------------------------------------------------------------------------------------------------------------------------------*/

                #endregion

                Type groupType = typeof(DSGroup);

                Type edgeType = typeof(Edge);

                List<DSGroup> grouptoDelete = new List<DSGroup>();

                List<Edge> edgetoDelete = new List<Edge>();

                List<DSNode> nodesToDelete = new List<DSNode>();

                foreach(GraphElement element in selection)
                {
                    if(element is DSNode node)
                    {
                        nodesToDelete.Add(node);

                        continue;
                    }

                    if(element.GetType() == edgeType)
                    {
                        Edge edge = (Edge) element;

                        edgetoDelete.Add(edge);

                        continue;
                    }

                    if(element.GetType() != groupType)
                    {
                        continue;
                    }

                    DSGroup group = (DSGroup) element;
                    
                    grouptoDelete.Add(group);
                }

                foreach(DSGroup group in grouptoDelete)
                {
                    List<DSNode> groupNodes = new List<DSNode>();

                    foreach(GraphElement groupElement in group.containedElements)
                    {
                        if(!(groupElement is DSNode))
                        {
                            continue ;
                        }

                        DSNode node = (DSNode) groupElement;    

                        groupNodes.Add(node);

                    }

                    #region Vấn đề A-2: Dòng group.RemoveElements(groupNodes) có ý nghĩa gì ?

                    /*--------------------------------------------------------------------------------------------------------------------------------------------*/

                    /*
                    Dòng group.RemoveElements(groupNodes); đến từ phương thức của lớp Group trong Unity's GraphView API.

                    Nó đến từ đâu và có tác dụng gì?

                    RemoveElements(IEnumerable < GraphElement > elements) là một phương thức của lớp Group, có chức năng loại bỏ các phần tử(Node) khỏi Group.

                    Khi gọi group.RemoveElements(groupNodes);, nó sẽ:

                    1.Xóa các Node trong danh sách groupNodes khỏi Group.

                    2.Kích hoạt sự kiện elementsRemovedFromGroup, từ đó GraphView có thể xử lý lại danh sách Node.

                    3.Trả các Node bị xóa về trạng thái "ungrouped", nếu bạn đã xử lý sự kiện elementsRemovedFromGroup đúng cách.
                  
                    */
                    /*--------------------------------------------------------------------------------------------------------------------------------------------*/

                    #endregion


                    #region Câu hỏi của vấn đề A-2: Tại sao phải gọi dòng này trước khi RemoveElement(group);
                    /*--------------------------------------------------------------------------------------------------------------------------------------------*/

                    /*
                    ?.Tại sao phải gọi dòng này trước khi RemoveElement(group);?

                    Nếu bạn chỉ gọi RemoveElement(group); mà không xóa các Node trước, có thể xảy ra các vấn đề:

                    1.Các Node vẫn còn trong GraphView nhưng không còn thuộc về Group.

                     - Điều này có thể gây lỗi khi truy cập group.containedElements, vì Group đã bị xóa.

                    2.Không kích hoạt callback elementsRemovedFromGroup.

                     -Nếu không gọi RemoveElements, sự kiện elementsRemovedFromGroup sẽ không chạy, và các Node sẽ không được cập nhật trạng thái.

                    3.Dữ liệu trong groupedNodes có thể bị sai.

                     - Nếu Group bị xóa mà các Node vẫn còn, danh sách groupedNodes có thể chứa thông tin không hợp lệ.

                    Tóm lại

                    Dòng group.RemoveElements(groupNodes); giúp xóa đúng cách các Node khỏi Group trước khi xóa chính Group đó, đảm bảo hệ thống GraphView cập nhật đúng trạng thái của các Node.
                    */

                    /*--------------------------------------------------------------------------------------------------------------------------------------------*/

                    #endregion

                    group.RemoveElements(groupNodes);

                    RemoveGroup(group);

                    RemoveElement(group);
                }

                DeleteElements(edgetoDelete);

                foreach(DSNode node in nodesToDelete)
                {
                    if(node.Group != null)
                    {
                        node.Group.RemoveElement(node);
                    }

                    RemoveUnGroupNode(node);

                    node.DisconnectAllPorts();

                    RemoveElement(node);
                }
            };
        }

        private void OngroupElementsAdded()
        {
            elementsAddedToGroup = (group, elements) =>
            {
                foreach(GraphElement element in elements)
                {
                    if(!(element is DSNode))
                    {
                        continue;
                    }

                    DSGroup nodeGroup = (DSGroup) group;

                    DSNode node = (DSNode) element;

                    RemoveUnGroupNode(node);

                    AddGroupedNode(node, nodeGroup);
                } 
            };
        }

        private void OngroupElementsRemoved()
        {
            elementsRemovedFromGroup = (group, elements) =>
            {
                foreach (GraphElement element in elements)
                {
                    if (!(element is DSNode))
                    {
                        continue;
                    }

                    DSNode node = (DSNode)element;

                    RemoveGroupedNode(node, group);

                    AddUnGroupNode(node);
                }
            };
        }

        private void OnGroupRenamed()
        {
            groupTitleChanged = (group, newtitle) =>
            {
                DSGroup dSGroup = (DSGroup) group;

                dSGroup.title = newtitle.RemoveWhitespaces().RemoveSpecialCharacters();

                if (string.IsNullOrEmpty(dSGroup.title))
                {
                    if (!string.IsNullOrEmpty(dSGroup.oldtitle))
                    {
                        ++nameErrorAmount;
                    }
                }
                else
                {
                    if (string.IsNullOrEmpty(dSGroup.oldtitle))
                    {
                        --nameErrorAmount;
                    }
                }

                RemoveGroup(dSGroup);

                /*Nếu muốn có WhiteSpaces cho tên Group thì thay dSGroup.oldtitle bằng newtitle*/
                dSGroup.oldtitle = dSGroup.title;

                AddGroup(dSGroup);
            };
        }

        private void OnGraphViewChanged()
        {
            graphViewChanged = (changes) =>
            {
                if (changes.edgesToCreate != null)
                {
                    foreach (Edge edge in changes.edgesToCreate)
                    {
                        DSNode nextNode = (DSNode)edge.input.node;

                        DSChoiceSaveData choiceData = (DSChoiceSaveData)edge.output.userData;

                        choiceData.NodeID = nextNode.ID;
                    }
                }

                if (changes.elementsToRemove != null)
                {
                    Type edgeType = typeof(Edge);

                    foreach (GraphElement element in changes.elementsToRemove)
                    {
                        if (element.GetType() != edgeType)
                        {
                            continue;
                        }

                        Edge edge = (Edge)element;

                        DSChoiceSaveData choiceData = (DSChoiceSaveData)edge.output.userData;

                        choiceData.NodeID = "";
                    }
                }

                return changes;
            };
        }

        #endregion
    }
}
</file>

<file path="DialogueSystem/Windows/DSGraphView.cs.meta">
fileFormatVersion: 2
guid: dcd44b1d3cca39b48a0c22011f3efaab
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="DialogueSystem/Windows/DSSearchWindow.cs">
using System.Collections.Generic;
using UnityEditor.Experimental.GraphView;
using UnityEngine;

namespace DS.Windows
{
    using DS.windows;
    using Elements;
    using Enumerations;

    /*--------------------------------------------------------------------------------------------------------------------*/

    /*DSSearchWindow là cửa sổ menu để tạo ra các Node và Group*/

    /*ISearchWindowProvider cung cấp 2 phương thức là CreateSearchTree và OnSelectEntry để khởi tạo và quản lí window menu*/

    /*--------------------------------------------------------------------------------------------------------------------*/


    public class DSSearchWindow : ScriptableObject, ISearchWindowProvider
    {
        private DSGraphView graphView;
        private Texture2D indentationIcon;

        public void Initialize(DSGraphView dsGraphView)
        {
            graphView = dsGraphView;

            indentationIcon = new Texture2D(1, 1);
            indentationIcon.SetPixel(0, 0, Color.clear);
            indentationIcon.Apply();
        }


        /*--------------------------------------------------------------------------------------------------------------------*/

        /*Tác dụng của CreateSearchTree: Populates the search window menu */

        /*SearchTreeGroupEntry đóng vai trò là các thành phần trong menu */

        /*SearchTreeEntry đóng vai trò là các tùy chọn của thành phần trong menu đó */

        /*Biến userData sẽ phục vụ cho phương thức OnSelectEntry để kiểm tra xem tùy chọn nào đã được chọn */

        /*--------------------------------------------------------------------------------------------------------------------*/



        public List<SearchTreeEntry> CreateSearchTree(SearchWindowContext context)
        {
            List<SearchTreeEntry> searchTreeEntries = new List<SearchTreeEntry>()
            {
                new SearchTreeGroupEntry(new GUIContent("Create Elements")),

                new SearchTreeGroupEntry(new GUIContent("Dialogue Nodes"), 1),

                new SearchTreeEntry(new GUIContent("Single Choice", indentationIcon))
                {
                    userData = DSDialogType.SingleChoice,
                    level = 2
                },

                new SearchTreeEntry(new GUIContent("Multiple Choice", indentationIcon))
                {
                    userData = DSDialogType.MultipleChoice,
                    level = 2
                },

                new SearchTreeGroupEntry(new GUIContent("Dialogue Groups"), 1),

                new SearchTreeEntry(new GUIContent("Single Group", indentationIcon))
                {
                    userData = new Group(),
                    level = 2
                }
            };

            return searchTreeEntries;
        }

        /*--------------------------------------------------------------------------------------------------------------------*/

        /*Tác dụng của OnSelectEntry: What to do when a certain menu is pressed */

        /*localMousePosition có tác dụng giúp cho các Nodes và Group được tạo ở vị trí con trỏ chuột tại thời điểm khỏi tạo */

        /*--------------------------------------------------------------------------------------------------------------------*/

        public bool OnSelectEntry(SearchTreeEntry SearchTreeEntry, SearchWindowContext context)
        {
            Vector2 localMousePosition = graphView.GetLocalMousePosition(context.screenMousePosition, true);

            switch (SearchTreeEntry.userData)
            {
                case DSDialogType.SingleChoice:
                    {
                        DSSingleChoiceNode singleChoiceNode = (DSSingleChoiceNode)graphView.CreateNode("DialogueName", DSDialogType.SingleChoice, localMousePosition);

                        graphView.AddElement(singleChoiceNode);

                        return true;
                    }

                case DSDialogType.MultipleChoice:
                    {
                        DSMultipleChoiceNode multipleChoiceNode = (DSMultipleChoiceNode)graphView.CreateNode("DialogueName", DSDialogType.MultipleChoice, localMousePosition);

                        graphView.AddElement(multipleChoiceNode);

                        return true;
                    }

                case Group _:
                    {
                       graphView.CreateGroup("DialogueGroup", localMousePosition);
                    
                      return true;
                    }

                default:
                    {
                        return false;
                    }
            }
        }
    }
}
</file>

<file path="DialogueSystem/Windows/DSSearchWindow.cs.meta">
fileFormatVersion: 2
guid: 616efa0f50264c64b95000b752bfeafe
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="DontDestroyOnLoad.cs">
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class DontDestroyOnLoad : MonoBehaviour
{
    private void Awake()
    {
        DontDestroyOnLoad(gameObject);
    }
}
</file>

<file path="DontDestroyOnLoad.cs.meta">
fileFormatVersion: 2
guid: f459fee114d69054386cbe7e30183676
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="EnemyManager.meta">
fileFormatVersion: 2
guid: d0253128d6a1f43418c0dd5aca4ac00e
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="EnemyManager/ResetAnimatorParameter.cs">
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class ResetAnimatorParameter : StateMachineBehaviour
{
    public string targetBool;
    public bool status;

    // OnStateEnter is called when a transition starts and the state machine starts to evaluate this state
    override public void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
    {
        animator.SetBool(targetBool, status);
    }

}
</file>

<file path="EnemyManager/ResetAnimatorParameter.cs.meta">
fileFormatVersion: 2
guid: ab93ff7d5ad8c4c489f4cd788018e2f4
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="GameManager.meta">
fileFormatVersion: 2
guid: e8b9b87c7f23b8e49a80c4ce05b18777
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="GameManager/AudioManager.cs">
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class AudioManager : MonoBehaviour
{
    public static AudioManager instance;
    [Header("Audio Clip")]
    public AudioClip hoverSound;
    public AudioClip chooseSound;
    public AudioClip correctSound;
    public AudioClip ambientSound;
    public AudioClip ambientWinSound;

    [Header("Vollume Settings")]
    [Range(0.0f, 1.0f)]
    public float backgroundVollume = 1f;
    [Range(0.0f, 1.0f)]
    public float triggerVollume = 1f;

    AudioSource ambientSource;
    AudioSource triggerSource;

    private void Awake()
    {
        if (instance == null)
        {
            instance = this;
            DontDestroyOnLoad(gameObject);
            //
            ambientSource = gameObject.AddComponent<AudioSource>();
            triggerSource = gameObject.AddComponent<AudioSource>();
        }
        else
        {
            Destroy(this);
        }
    }

    private void Start()
    {
        //PlayBackgroundAmbient();
    }

    public void PlayHoverSound()
    {
        triggerSource.loop = false;
        triggerSource.volume = triggerVollume;
        if (!triggerSource.isPlaying)
        {
            triggerSource.clip = hoverSound;
            triggerSource.Play();
        }
    }

    public void PlayChooseSound()
    {
        triggerSource.loop = false;
        triggerSource.volume = triggerVollume;
        if (!triggerSource.isPlaying)
        {
            triggerSource.clip = chooseSound;
            triggerSource.Play();
        }
    }

    public void PlayCorrectSound()
    {
        triggerSource.loop = false;
        triggerSource.volume = triggerVollume;
        if (!triggerSource.isPlaying)
        {
            triggerSource.clip = correctSound;
            triggerSource.Play();
        }
    }

    public void PlayBackgroundAmbient()
    {
        if (ambientSource.clip == ambientSound) return;

        ambientSource.loop = true;
        StartCoroutine(ChangeAudioClip(ambientSource, ambientSound, backgroundVollume, 1f, 1f));
    }

    public void PlayVictoryBackgroundAmbient()
    {
        if (ambientSource.clip == ambientWinSound) return;

        ambientSource.loop = true;
        StartCoroutine(ChangeAudioClip(ambientSource, ambientWinSound, backgroundVollume, 1f, 1f));
    }

    IEnumerator ChangeAudioClip(AudioSource source, AudioClip targetClip, float maxVollume, float fadeOutTime, float fadeInTime)
    {
        fadeInTime += 0.01f;
        fadeOutTime += 0.01f;
        //
        float timer = 0;
        //fade out
        while (timer < fadeOutTime)
        {
            timer += Time.deltaTime;
            float percentage = Mathf.Clamp01(timer / fadeOutTime);
            source.volume = (1 - percentage) * maxVollume;
            yield return new WaitForEndOfFrame();
        }

        //change source
        source.Stop();
        source.clip = targetClip;
        source.Play();

        //fade in
        timer = 0;
        while (timer < fadeInTime)
        {
            timer += Time.deltaTime;
            float percentage = Mathf.Clamp01(timer / fadeInTime);
            source.volume = percentage * maxVollume;
            yield return new WaitForEndOfFrame();
        }
    }
}
</file>

<file path="GameManager/AudioManager.cs.meta">
fileFormatVersion: 2
guid: d3c557fa02315344ebddcf9d83e90339
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="GameManager/GameUI.meta">
fileFormatVersion: 2
guid: efe446e881bc2204f805cf6f18fba78f
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="GameManager/GameUI/ConservationManager.cs">
using DS.ScriptableObjects;
using System.Collections;
using System.Collections.Generic;
using TMPro;
using UnityEngine;
using UnityEngine.UI;

namespace Interaction
{
    public class ConservationManager : MonoBehaviour
    {
        public static ConservationManager instance;
        [Header("NPC Message")]
        public UIAnimationController messageContainer;
        public TMP_Text npcMessage;
        public TMP_Text npcName;
        public TMP_Text npcRole;

        [Header("Player Response")]
        public UIAnimationController responseController;
        public GameObject responsePrefab;
        public Sprite defautIcon;

        GameObject targetNPC;
        NPCConservationSO conservationData;

        private void Awake()
        {
            instance = this;
        }


        public void InitConservation(GameObject npc, DialogConservation dialog)
        {
            targetNPC = npc;
            NPCController npcController = npc.GetComponent<NPCController>();
            if (npcController)
            {
                npcName.text = npcController.npcInfo.npcName;
                npcRole.text = npcController.npcInfo.npcRole;
            }
            SetupDialogInConservation(dialog);
            StartCoroutine(ActivateConservationDialog());
        }

        public void InitConservation(GameObject npc, NPCConservationSO conservation)
        {
            targetNPC = npc;
            conservationData = conservation;

            //update name and role text
            NPCController npcController = npc.GetComponent<NPCController>();
            if (npcController)
            {
                npcName.text = npcController.npcInfo.npcName;
                npcRole.text = npcController.npcInfo.npcRole;
            }
            

            //setup first conservation
            DialogConservation firstDialog;
            if(conservationData.startFromFirstDialog)
            {
                firstDialog = conservation.dialogs[0];
            } else
            {
                //can get a random dialog
                firstDialog = conservation.dialogs[0];
            }
            SetupDialogInConservation(firstDialog);
        }

        public void ChangeTargetNPC(GameObject npc) { targetNPC = npc; }

        void SetupDialogInConservation(DialogConservation dialog)
        {
            //Setup npc message
            npcMessage.text = dialog.message;
   
            //Setup player response
            //Clear old responses in container
            foreach (Transform child in responseController.transform)
            {
                child.gameObject.SetActive(false);
            }

            //Add new response
            for(int i = 0; i < dialog.possibleResponses.Count; i++)
            {
                DialogResponse responseData = dialog.possibleResponses[i];

                //find or create response object
                GameObject responseObject;
                if (i < responseController.transform.childCount)
                {
                    responseObject = responseController.transform.GetChild(i).gameObject;
                } else
                {
                    responseObject = Instantiate(responsePrefab, responseController.transform);
                }

                //setup response data
                responseObject.GetComponentInChildren<TMP_Text>().text = responseData.message;
                responseObject.transform.GetChild(1).GetComponent<Image>().sprite = responseData.icon != null? responseData.icon : defautIcon;
                responseObject.GetComponent<Button>().onClick.AddListener(delegate () 
                {
                    if (!string.IsNullOrEmpty(responseData.nextDialogId))
                    {
                        Debug.Log($"Looking for next node with ID: {responseData.nextDialogId}");

                        // Lấy adapter từ targetNPC, nếu chưa có thì thử dùng DialogueManager
                        NPCController npcController = targetNPC.GetComponent<NPCController>();
                        DSDialogueAdapter dialogueAdapter = targetNPC.GetComponent<DSDialogueAdapter>();
                      

                        DSDialogueSO nextNode = dialogueAdapter != null ? dialogueAdapter.GetNodeByName(responseData.nextDialogId) : null;
                        if (nextNode != null)
                        {
                            Debug.Log($"Found next node: {nextNode.DialogueName}");
                            DialogConservation nextCons = dialogueAdapter.ConvertDSDialogueToConservation(nextNode);
                            StartCoroutine(UpdateConservation(nextCons));

                            // Gửi lệnh dựa trên ExecutedFunction của node tiếp theo, không của response hiện tại.
                            if (nextNode.ExecutedFunction != DialogExecuteFunction.None)
                            {
                                targetNPC.SendMessage(nextNode.ExecutedFunction.ToString());
                                Debug.Log(nextNode.ExecutedFunction.ToString());
                            }
                        }
                        else
                        {
                            Debug.LogError($"Could not find next node with ID: {responseData.nextDialogId}");
                            Debug.Log($"Current nodeLookup count: {(dialogueAdapter != null ? dialogueAdapter.GetNodeLookupCount() : 0)}");
                            if (dialogueAdapter != null)
                            {
                                dialogueAdapter.LogNodeNames();
                            }
                        }
                    }
                    else
                    {
                        // Get the TalkInteraction component from the target NPC
                        TalkInteraction talkInteraction = targetNPC.GetComponent<TalkInteraction>();
                        if (talkInteraction != null)
                        {
                            talkInteraction.StopInteract();
                        }
                        else
                        {
                            Debug.LogError($"No TalkInteraction component found on NPC: {targetNPC.name}");
                        }
                    }
                });




                responseObject.SetActive(true);
            }
            responseController.UpdateObjectChange();
        }

        void ClearAllButtonEvent()
        {
            Button[] btns = responseController.GetComponentsInChildren<Button>();
            foreach(Button b in btns)
            {
                b.onClick.RemoveAllListeners();
            }
            //
            DisableAllButton();
        }

        void EnableAllButton()
        {
            Button[] btns = responseController.GetComponentsInChildren<Button>();
            foreach (Button b in btns)
            {
                b.interactable = true;
            }
        }

        void DisableAllButton()
        {
            Button[] btns = responseController.GetComponentsInChildren<Button>();
            foreach (Button b in btns)
            {
                b.interactable = false;
            }
        }
        public IEnumerator UpdateConservation(DialogConservation nextDialog)
        {
            ClearAllButtonEvent();
            responseController.Deactivate();
            
            yield return new WaitForSeconds(0.4f);
            messageContainer.Deactivate();
            
            yield return new WaitForSeconds(0.6f);
            SetupDialogInConservation(nextDialog);
            messageContainer.Activate();

            yield return new WaitForSeconds(0.2f);
            responseController.Activate();
            EnableAllButton();
            yield return null;
        }

        public IEnumerator ActivateConservationDialog()
        {
            messageContainer.Activate();
            yield return new WaitForSeconds(0.3f);
            responseController.Activate();
            EnableAllButton();
        }

        public IEnumerator DeactivateConservationDialog()
        {
            ClearAllButtonEvent();
            responseController.Deactivate();
            yield return new WaitForSeconds(0.3f);
            messageContainer.Deactivate();
        }
    }
}
</file>

<file path="GameManager/GameUI/ConservationManager.cs.meta">
fileFormatVersion: 2
guid: 0d122f03abaef8a4c92fb368ecb4039b
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="GameManager/GameUI/Inventory.meta">
fileFormatVersion: 2
guid: c0f586d6f20419347a86f0120654b088
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="GameManager/GameUI/Inventory/InventoryItemUI.cs">
using System.Collections;
using System.Collections.Generic;
using TMPro;
using UnityEngine;
using UnityEngine.UI;

public class InventoryItemUI : MonoBehaviour
{
    public Image itemImage;
    public Button useBtn;
    public TMP_Text quantityText;

    public void InitInventorySlot(InventoryItem item, int slotIndex)
    {
        itemImage.sprite = item.item.itemImage;
        itemImage.enabled = true;
        quantityText.text = item.quantity.ToString();
        useBtn.onClick.AddListener(delegate
        {
            PlayerInventory.instance.TryUseItem(slotIndex);
        });
    }

    public void ResetInventorySlot()
    {
        itemImage.sprite = null;
        itemImage.enabled = false;
        useBtn.onClick.RemoveAllListeners();
        quantityText.text = string.Empty;
    }
}
</file>

<file path="GameManager/GameUI/Inventory/InventoryItemUI.cs.meta">
fileFormatVersion: 2
guid: b8d06d0ff1036084fa4bfb78ba82322d
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="GameManager/GameUI/Inventory/InventoryUIManager.cs">
using PlayerController;
using System.Collections;
using System.Collections.Generic;
using TMPro;
using UnityEngine;
using UnityEngine.UI;

public class InventoryUIManager : MonoBehaviour
{
    public TMP_Text goldText;
    public GameObject itemPrefab;
    public Transform inventoryContainer;
    public Button closeBtn;

    UIAnimationController uiAnimation;

    private void Awake()
    {
        uiAnimation = GetComponent<UIAnimationController>();
        closeBtn.onClick.AddListener(delegate
        {
            StartCoroutine(CloseWindow());
        });
        //
    }

    private void Start()
    {
        PlayerInventory.instance.OnGoldChanged += UpdateGoldText;
        PlayerInventory.instance.OnInventoryUpdated += OnInventoryChange;
    }

    public void UpdateGoldText(int changeAmount, int goldAmount)
    {
        goldText.text = goldAmount.ToString();
    }

    public void OnInventoryChange(Dictionary<int, InventoryItem> inventory)
    {
        InitInventory();
    }

    public void InitInventory()
    {
        List<InventoryItem> inventoryItems = PlayerInventory.instance.inventoryItems;
        //

        for(int i = 0; i < inventoryItems.Count; i ++)
        {
            InventoryItemUI inventoryItemUI = inventoryContainer.GetChild(i).GetComponent<InventoryItemUI>();
            inventoryItemUI.ResetInventorySlot();
            
            if (!inventoryItems[i].IsEmpty)
            {
                inventoryItemUI.InitInventorySlot(inventoryItems[i], i);
            }
        }
    }

    private void Update()
    {
        if(Input.GetKeyUp(KeyCode.I))
        {
            InitInventory();
            StartCoroutine(OpenWindow());
        }
    }

    public IEnumerator CloseWindow()
    {
        uiAnimation.Deactivate();
        yield return new WaitForSeconds(0.7f);
        PlayerManager.instance.ActivateController();
    }

    public IEnumerator OpenWindow()
    {
        PlayerManager.instance.DeactivateController();
        yield return new WaitForSeconds(0.7f);
        uiAnimation.Activate();
    }
}
</file>

<file path="GameManager/GameUI/Inventory/InventoryUIManager.cs.meta">
fileFormatVersion: 2
guid: b2b8d9b14598f8847bb62ad6f1dcccbb
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="GameManager/GameUI/Shop.meta">
fileFormatVersion: 2
guid: 7a797007d08bc4c4dba68f61b033a0f7
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="GameManager/GameUI/Shop/ShopProductUI.cs">
using System.Collections;
using System.Collections.Generic;
using TMPro;
using UnityEngine;
using UnityEngine.UI;

public class ShopProductUI : MonoBehaviour
{
    public Image productImage;
    public TMP_Text priceText;
    public TMP_Text valueText;
    public Image valueIcon;
    public Button buyBtn;

    ShopItem shopItem;

    public void Init(ShopItem item)
    {
        shopItem = item;
        productImage.sprite = item.itemInfo.itemImage;
        priceText.text = item.price.ToString();
        valueText.text = item.value;
        valueIcon.sprite = item.valueIcon;
        //
        buyBtn.onClick.AddListener(delegate
        {
            bool isBuySuccess = shopItem.TryBuyItem();
            if(isBuySuccess)
            {
                Debug.Log("Success");
            } else
            {
                Debug.Log("Fail");
            }
        });
    }
}
</file>

<file path="GameManager/GameUI/Shop/ShopProductUI.cs.meta">
fileFormatVersion: 2
guid: ee8810dc3551986438904e66f9f51e00
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="GameManager/GameUI/Shop/ShopWindowManager.cs">
using Interaction;
using PlayerController;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;

public class ShopWindowManager : MonoBehaviour
{
    public static ShopWindowManager instance;

    public GameObject categoryPrefab;
    public GameObject productPrefab;
    public Transform itemContainer;
    public Scrollbar containerScroll;
    public Button prevBtn;
    public Button nextBtn;
    public Button closeBtn;

    UIAnimationController openAnimation;
    ShopWindowDataSO data;
    int currentStep = 0;
    int stemNums = 5;

    private void Awake()
    {
        instance = this;
        openAnimation = GetComponent<UIAnimationController>();
    }

    private void Start()
    {
        prevBtn.onClick.AddListener(delegate { PreviousTab(); });
        nextBtn.onClick.AddListener(delegate { NextTab(); });
        closeBtn.onClick.AddListener(delegate { CloseWindow(); });
    }

    public void OpenWindow(ShopWindowDataSO data)
    {
        
        this.data = data;
        InitShop();
        StartCoroutine(ActivateWindow());
    }

    public void InitShop()
    {
        //delete old objects
        for(int i = 0; i < itemContainer.childCount; i ++)
        {
            Destroy(itemContainer.GetChild(i).gameObject);
        }

        //create new objects
        for (int i = 0; i < data.shopCategories.Count; i ++)
        {
            GameObject category = Instantiate(categoryPrefab, itemContainer);
            List<ShopItem> items = data.shopCategories[i].shopItems;
            
            for(int j = 0; j < items.Count; j ++)
            {
                ShopProductUI productUI = Instantiate(productPrefab, category.transform).GetComponent<ShopProductUI>();
                productUI.Init(items[j]);
            }
        }

        stemNums = data.shopCategories.Count;

        openAnimation.UpdateObjectChange();
    }

    IEnumerator ActivateWindow()
    {
        yield return ConservationManager.instance.DeactivateConservationDialog();
        yield return new WaitForSeconds(0.7f);
        openAnimation.Activate();
    }

    public void CloseWindow()
    {
        StartCoroutine(DeactivateWindow());
    }

    IEnumerator DeactivateWindow()
    {
        openAnimation.Deactivate();
        yield return new WaitForSeconds(0.7f);
        PlayerManager.instance.ActivateController();
    }

    public void NextTab()
    {
        currentStep++;
        currentStep = currentStep % stemNums;
        containerScroll.value = currentStep * (1f / (stemNums - 1));
    }

    public void PreviousTab()
    {
        currentStep--;
        if(currentStep < 0)
        {
            currentStep = stemNums - 1;
        }
        containerScroll.value = currentStep * (1f / (stemNums - 1));
    }
}
</file>

<file path="GameManager/GameUI/Shop/ShopWindowManager.cs.meta">
fileFormatVersion: 2
guid: 05eb2346558d9c24892660f2b97b50d3
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences:
  - categoryPrefab: {fileID: 5492579844062596145, guid: 2c069e8bf16978940b0513069f20d471,
      type: 3}
  - productPrefab: {fileID: 5109114692234700783, guid: 7d8bd51ee3f1efe4893d9c2daf4c80f6,
      type: 3}
  - itemContainer: {instanceID: 0}
  - containerScroll: {instanceID: 0}
  - prevBtn: {instanceID: 0}
  - nextBtn: {instanceID: 0}
  - closeBtn: {instanceID: 0}
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="GameManager/GameUI/UIManager.cs">
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace GameManager
{
    public class UIManager : MonoBehaviour
    {
        [Header("UI Window")]
        public UIAnimationController hudWindow;
    }
}
</file>

<file path="GameManager/GameUI/UIManager.cs.meta">
fileFormatVersion: 2
guid: 86960557ccb04554daa2a491e6c6e3ec
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="GameManager/Minigame.meta">
fileFormatVersion: 2
guid: 392f0e0feffb14e4c8bec89fea98d324
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="GameManager/Minigame/CollectQuestManager.cs">
using GameManager;
using Interaction.Minigame;
using System;
using System.Collections.Generic;
using UnityEngine;

public class CollectQuestManager : MonoBehaviour
{
    public static CollectQuestManager instance;

    [HideInInspector]public Dictionary<string, CollectQuest> collectQuests = new Dictionary<string, CollectQuest>();
    GameObject container;

    private void Awake()
    {
        instance = this;
    }

    public void InitCollectQuest(GameObject targetNPC, GameObject coinContainer, LootEventSO lootEvent)
    {
        container = coinContainer;
        //
        CoinLootInteraction[] coins = coinContainer.GetComponentsInChildren<CoinLootInteraction>();
        foreach(CoinLootInteraction coin in coins)
        {
            coin.SetupCoinMinigame(lootEvent.minigameId);
        }

        //setup collect quest
        CollectQuest collectQuest = new CollectQuest();
        collectQuest.numberToCollect = lootEvent.numberOfLoot;
        collectQuest.OnFinishQuest = () => {
            targetNPC.SendMessage("OnQuestMinigameSuccess");
        };
        collectQuests.Add(lootEvent.minigameId, collectQuest);

        //setup quest complete callback
        QuestManager.instance.questMap[lootEvent.questId].OnQuestFinish += OnMainQuestComplete;
    }

    public void OnMainQuestComplete()
    {
        Destroy(container);
    }

    public void OnCollectQuestChange(string minigameId)
    {
        CollectQuest quest = collectQuests[minigameId];
        quest.OnCollectedChange();
    }
}

public class CollectQuest
{
    public int numberToCollect;
    public int currentCollected;

    public Action OnFinishQuest;

    public void OnCollectedChange()
    {
        currentCollected++;
        Debug.Log(currentCollected + "/" + numberToCollect);
        if(currentCollected == numberToCollect)
        {
            OnFinishQuest?.Invoke();
        }
    }
}
</file>

<file path="GameManager/Minigame/CollectQuestManager.cs.meta">
fileFormatVersion: 2
guid: b7830285981ea3b48acb11dc1af3033e
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="GameManager/Minigame/MazeSceneManager.cs">
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.SceneManagement;

public class MazeSceneManager : SubSceneGameManager
{
    public CoinLootInteraction[] targets;

    public override void InitGame(GameObject targetNPC, MinigameDataSO minigameData, string sceneName)
    {
        base.InitGame(targetNPC, minigameData, sceneName);
        //
        foreach (CoinLootInteraction coin in targets)
        {
            coin.SetupCoinMinigame(minigameData.minigameId);
        }

        //setup collect quest
        CollectQuest collectQuest = new CollectQuest();
        collectQuest.numberToCollect = targets.Length;
        collectQuest.OnFinishQuest = () => {
            targetNPC.SendMessage("OnQuestMinigameSuccess");
            //
            StartCoroutine(ExitScene(3f));
        };
        CollectQuestManager.instance.collectQuests.Add(minigameData.minigameId, collectQuest);
    }

    IEnumerator ExitScene(float delay = 0)
    {
        yield return new WaitForSeconds(delay);
        SceneManager.UnloadSceneAsync(sceneName);
    }
}
</file>

<file path="GameManager/Minigame/MazeSceneManager.cs.meta">
fileFormatVersion: 2
guid: a0549f5042e8d104b9af8f49aa981ca3
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="GameManager/Minigame/QuizManager.cs">
using Interaction.Minigame;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Interaction
{
    public class QuizManager : MonoBehaviour
    {
        public static QuizManager instance;

        GameObject targetNPC;
        QuizConservationSO quizData;
        ConservationManager conservationManager;
        List<QuestionAndAnswer> temporaryQnas;
        QuestionAndAnswer curQNA;
        int currentQuestion = 0;
        int correctAnswers = 0;
        int wrongAnswers = 0;

        private void Awake()
        {
            instance = this;
            conservationManager = FindObjectOfType<ConservationManager>();
        }

        public void InitAndStartQuizData(GameObject targetNPC, QuizConservationSO quiz)
        {
            ResetQuizMission();
            quizData = quiz;
            this.targetNPC = targetNPC;
            temporaryQnas = new List<QuestionAndAnswer>(quizData.qnas);
            conservationManager.ChangeTargetNPC(gameObject);

            //intro dialog
            DialogConservation intro = quizData.quizIntro;
            intro.possibleResponses[0].executedFunction = DialogExecuteFunction.NextQuiz;
            StartCoroutine(conservationManager.UpdateConservation(intro));
        }

        public void ResetQuizMission()
        {
            currentQuestion = 0;
            correctAnswers = 0;
            wrongAnswers = 0;
        }

        public void NextQuiz()
        {
            if(currentQuestion >= quizData.numberOfQuestion || wrongAnswers > quizData.numberOfMaxWrong)
            {
                FinishQuiz();
                return;
            }
            
            //init next question
            curQNA = GetRandomQuestion();
            DialogConservation quiz = new DialogConservation();
            quiz.message = curQNA.Question;

            for (int i = 0; i < curQNA.Answers.Length; i++)
            {
                DialogResponse response = new DialogResponse();
                response.message = curQNA.Answers[i];
                response.executedFunction = (curQNA.CorrectAnswer - 1 == i) ? DialogExecuteFunction.AnswerCorrect : DialogExecuteFunction.AnswerWrong;
                quiz.possibleResponses.Add(response);
            }
            StartCoroutine(conservationManager.UpdateConservation(quiz));
            currentQuestion++;
        }

        public void FinishQuiz()
        {
            //change target NPC to original NPC
            conservationManager.ChangeTargetNPC(targetNPC);
            
            //create dialog
            DialogConservation correctDialog = new DialogConservation();
            DialogResponse response = new DialogResponse();
            
            if (wrongAnswers > quizData.numberOfMaxWrong)
            {
                correctDialog.message = "Tiếc quá, em đã trả lời <color=#FF6100>sai quá "+ quizData.numberOfMaxWrong +" câu</color> rồi. Tôi nghĩ là em cần thêm thời gian để tìm hiểu về trường. Hãy quay lại đây <color=#FF6100>sau 5 phút</color> nữa nhé.";
                response.executedFunction = DialogExecuteFunction.OnQuestMinigameFail;
            } else
            {
                correctDialog.message = "Thật tuyệt vời, em đã trả lời đúng <color=#06FFE6>" + correctAnswers + "/" + 8 + " câu hỏi</color> rồi. Tôi tin là sau cuộc trò chuyện này em đã có thêm nhiều hiểu biết về trường mình.";
                response.executedFunction = DialogExecuteFunction.OnQuestMinigameSuccess;
            }
            
            response.message = "Vâng ạ";
            correctDialog.possibleResponses.Add(response);
            //
            StartCoroutine(conservationManager.UpdateConservation(correctDialog));
        }

        public void AnswerCorrect()
        {
            correctAnswers++;
            DialogConservation correctDialog = new DialogConservation();

            correctDialog.message = "Đáp án <color=#06FFE6>chính xác</color>. " + curQNA.Explaination; 
            if(currentQuestion < quizData.numberOfQuestion) 
            {
                correctDialog.message += " Sau đây là câu hỏi tiếp theo.";
            }
            
            DialogResponse response = new DialogResponse();
            response.message = "Vâng ạ";
            response.executedFunction = DialogExecuteFunction.NextQuiz;
            correctDialog.possibleResponses.Add(response);
            //
            StartCoroutine(conservationManager.UpdateConservation(correctDialog));
        }

        public void AnswerWrong()
        {
            wrongAnswers++;
            bool isFail = (wrongAnswers > quizData.numberOfMaxWrong);
            if (isFail)
            {
                FinishQuiz();
                return;
            }

            bool isAboutToFail = (wrongAnswers > quizData.numberOfMaxWrong - 1);

            DialogConservation wrongDialog = new DialogConservation();
            wrongDialog.message = "Đáp án <color=#FF6100>không chính xác</color>. Em đã trả lời <color=#FF6100>sai "
                + wrongAnswers + " câu</color> rồi." 
                + ((isAboutToFail) ? " Em chỉ <color=#FF6100>còn 1 cơ hội</color> nữa thôi. Hãy thật cẩn thận nhé." : " Hãy thật bình tĩnh trong câu hỏi tiếp theo nhé.");
            
            DialogResponse response = new DialogResponse();
            response.message = "Vâng ạ";
            response.executedFunction = DialogExecuteFunction.NextQuiz;
            wrongDialog.possibleResponses.Add(response);
            //
            StartCoroutine(conservationManager.UpdateConservation(wrongDialog));
            
        }

        QuestionAndAnswer GetRandomQuestion()
        {
            int random = Random.Range(0, temporaryQnas.Count);
            QuestionAndAnswer qna = temporaryQnas[random];
            temporaryQnas.RemoveAt(random);
            return qna;
        }
    }
}
</file>

<file path="GameManager/Minigame/QuizManager.cs.meta">
fileFormatVersion: 2
guid: 5f8a744fa5f176d42bf961ec8276f575
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="GameManager/QuestManager.cs">
using Interaction;
using PlayerStatsController;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace GameManager
{
    public class QuestManager : MonoBehaviour
    {
        public static QuestManager instance;
        Dictionary<string, NPCController> npcMap;
        [HideInInspector] public Dictionary<string, Quest> questMap;
        PlayerStats playerStats;

        [Header("Config")]
        [SerializeField] private bool loadQuestState = true;

        private void Awake()
        {
            instance = this;
        }

        // Start is called before the first frame update
        void Start()
        {
            questMap = CreateQuestMap();
            npcMap = CreateNPCMap();
            playerStats = FindObjectOfType<PlayerStats>();
            UpdateRequirementsMetQuest();
        }

        #region Handle Quest Step Update

        public void UpdateRequirementsMetQuest()
        {
            // loop through ALL quests
            foreach (Quest quest in questMap.Values)
            {
                // if we're now meeting the requirements, switch over to the CAN_START state
                if (quest.state == QuestState.REQUIREMENTS_NOT_MET && CheckRequirementsMet(quest))
                {
                    quest.ChangeQuestState(QuestState.CAN_START);
                    InitQuestStep(quest.info.questSteps[quest.currentQuestStepIndex], quest.info.id);
                }
            }
        }

        public void InitQuestStep(QuestStep questStep, string questId)
        {
            NPCController npc = GetNPCById(questStep.npcId);
            npc.UpdateQuestStep(questStep, questId);
        }

        public void OnFinishQuestStep(string questId)
        {
            bool isQuestFinished = !questMap[questId].TryNextStep();
            Quest quest = questMap[questId];
            if (isQuestFinished)
            {
                Debug.Log("Quest complete..reward");
                playerStats.ExpGain(quest.info.experienceReward);
                PlayerInventory.instance.AddGold(quest.info.goldReward);

                for(int i = 0; i < quest.info.itemRewards.Count; i++)
                {
                    PlayerInventory.instance.AddItem(quest.info.itemRewards[i].item, quest.info.itemRewards[i].quantity);
                }
                
            } else
            {
                InitQuestStep(quest.info.questSteps[quest.currentQuestStepIndex], quest.info.id);
            }
        }

        #endregion

        #region Handle Reward
        public int CheckFinishedQuestsForMedals()
        {
            int medal = 0; // Reset Medal trước khi kiểm tra

            foreach (Quest quest in questMap.Values)
            {
                if (quest.state == QuestState.FINISHED)
                {
                    medal++; // Tăng số huân chương nếu quest đã hoàn thành
                }
            }

            return medal;
        }

        #endregion

        #region Handle Quest Manager Data

        private bool CheckRequirementsMet(Quest quest)
        {
            // start true and prove to be false
            bool meetsRequirements = true;

            // check player level requirements
            if (playerStats.characterLevel < quest.info.levelRequirement)
            {
                meetsRequirements = false;
            }

            // check quest prerequisites for completion
            foreach (QuestInfoSO prerequisiteQuestInfo in quest.info.questPrerequisites)
            {
                if (GetQuestById(prerequisiteQuestInfo.id).state != QuestState.FINISHED)
                {
                    meetsRequirements = false;
                }
            }

            return meetsRequirements;
        }

        private Quest GetQuestById(string id)
        {
            Quest quest = questMap[id];
            if (quest == null)
            {
                Debug.LogError("ID not found in the Quest Map: " + id);
            }
            return quest;
        }

        private Dictionary<string, Quest> CreateQuestMap()
        {
            // loads all QuestInfo Scriptable Objects under the Assets/Resources/Quests folder
            QuestInfoSO[] allQuests = Resources.LoadAll<QuestInfoSO>("Quests");
            
            // Create the quest map
            Dictionary<string, Quest> questMap = new Dictionary<string, Quest>();
            foreach (QuestInfoSO questInfo in allQuests)
            {
                if (questMap.ContainsKey(questInfo.id))
                {
                    Debug.LogWarning("Duplicate ID found when creating quest map: " + questInfo.id);
                }
                questMap.Add(questInfo.id, LoadQuest(questInfo));
            }
            return questMap;
        }

        private Quest LoadQuest(QuestInfoSO questInfo)
        {
            Quest quest = null;
            try
            {
                // load quest from saved data
                if (PlayerPrefs.HasKey(questInfo.id) && loadQuestState)
                {
                    string serializedData = PlayerPrefs.GetString(questInfo.id);
                    QuestData questData = JsonUtility.FromJson<QuestData>(serializedData);
                    quest = new Quest(questInfo, questData.state, questData.questStepIndex, questData.questStepStates);
                }
                // otherwise, initialize a new quest
                else
                {
                    quest = new Quest(questInfo);
                }
            }
            catch (System.Exception e)
            {
                Debug.LogError("Failed to load quest with id " + quest.info.id + ": " + e);
            }
            return quest;
        }

        private Dictionary<string, NPCController> CreateNPCMap()
        {
            NPCController[] npcs = FindObjectsOfType<NPCController>();

            // Create the quest map
            Dictionary<string, NPCController> npcMap = new Dictionary<string, NPCController>();
            foreach (NPCController npc in npcs)
            {
                if (npcMap.ContainsKey(npc.npcInfo.npcId))
                {
                    Debug.LogWarning("Duplicate ID found when creating NPC map: " + npc.npcInfo.npcId);
                }
                npcMap.Add(npc.npcInfo.npcId, npc);
            }
            return npcMap;
        }

        private NPCController GetNPCById(string id)
        {
            NPCController npc = npcMap[id];
            if (npc == null)
            {
                Debug.LogError("ID not found in the NPC Map: " + id);
            }
            return npc;
        }

        #endregion
    }
}
</file>

<file path="GameManager/QuestManager.cs.meta">
fileFormatVersion: 2
guid: 3b1cbac90505b7047a1fd0d34252c2bb
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="GameManager/SubSceneGameManager.cs">
using PlayerController;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class SubSceneGameManager : MonoBehaviour
{
    public static SubSceneGameManager instance;

    public string sceneName;
    public Transform spawnPlayerTransform;
    public Transform spawnCameraPivotTransform;
    [HideInInspector] public GameObject player;

    private void Awake()
    {
        instance = this;
        //
        player = GameObject.FindGameObjectWithTag("Player");
        player.GetComponent<Rigidbody>().position = spawnPlayerTransform.position;
        //
        FindObjectOfType<CameraHandle>().cameraPivotTransform.rotation = spawnCameraPivotTransform.rotation;
        //
        player.GetComponent<PlayerManager>().ActivateController();
    }

    public virtual void InitGame(GameObject targetNPC, MinigameDataSO minigameData, string sceneName)
    {
        this.sceneName = sceneName;
    }
}
</file>

<file path="GameManager/SubSceneGameManager.cs.meta">
fileFormatVersion: 2
guid: 6a49328fe3a7b6b4ab6fa6d07738c36f
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="InteractableObject.meta">
fileFormatVersion: 2
guid: c17f36aae811e144dbddf5495c70890c
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="InteractableObject/Item.meta">
fileFormatVersion: 2
guid: d34211ce63fb28848b82d58c84525b14
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="InteractableObject/Item/CoinLootInteraction.cs">
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class CoinLootInteraction : LootInteraction
{
    string questId = "";

    public void SetupCoinMinigame(string questId)
    {
        this.questId = questId;
    }

    public override void OnEnterCollider()
    {

        base.OnEnterCollider();

        if(questId != "")
        {
            CollectQuestManager.instance.OnCollectQuestChange(questId);
        }
        AudioManager.instance.PlayCorrectSound();
        gameObject.SetActive(false);
    }
}
</file>

<file path="InteractableObject/Item/CoinLootInteraction.cs.meta">
fileFormatVersion: 2
guid: dd268a814ff3de147949f225865d300e
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="InteractableObject/Item/LootInteraction.cs">
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class LootInteraction : MonoBehaviour
{
    [Header("Object Animation")]
    public Vector3 rotationSpeed;
    
    void Update()
    {
        transform.rotation = Quaternion.Euler(transform.rotation.eulerAngles + rotationSpeed * Time.deltaTime);
    }

    public virtual void OnEnterCollider() { }
    public virtual void OnStayCollider() { }

    private void OnTriggerEnter(Collider other)
    {
        if (other.CompareTag("Player"))
        {
            OnEnterCollider();
        }
    }

    private void OnTriggerStay(Collider other)
    {
        if (other.CompareTag("Player"))
        {
            OnStayCollider();
        }
    }
}
</file>

<file path="InteractableObject/Item/LootInteraction.cs.meta">
fileFormatVersion: 2
guid: 88e5d2ee499807e42ad22847145383ca
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="InteractableObject/NPC.meta">
fileFormatVersion: 2
guid: 9aebce58e8f1ec549afcc6a2406bd711
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="InteractableObject/NPC/NPCController.cs">
using DS;
using DS.ScriptableObjects;
using GameManager;
using Interaction;
using Interaction.Minigame;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class NPCController : TalkInteraction
{
    [Header("NPC infos")]
    public NPCInfoSO npcInfo;
    public DSDialogue dsDialogue;
    public DSDialogueContainerSO container;
    public NPCState currentNPCState;

    // Nếu dùng phương pháp manager-based, chuyển qua sử dụng DialogueManager.Instance.
    // Nếu false thì sử dụng component riêng trên NPC.
    [Header("Adapter Options")]
    public bool useManagerBasedAdapter = false;

    // Adapter sẽ được lấy theo 2 cách ở dưới:
    private DSDialogueAdapter dialogueAdapter;

    Dictionary<string, NPCConservationSO> npcConservationMap;
    Dictionary<string, MinigameDataSO> minigameDataMap;
    Dictionary<string, FunctionalWindowDataSO> functionalDataMap;

    [HideInInspector]
    public NPCConservationSO currentDialogConservation;
    QuestManager questManager;

    [Header("Quest Mission")]
    string questId;
    QuestStep questStep;

    [Header("State Symbol")]
    public GameObject iconDefault;
    public GameObject iconQuestAvailable;
    public GameObject iconQuestComplete;
    public GameObject iconQuestInProgress;

    void Start()
    {
        if (container == null)
        {
            Debug.LogError($"Dialogue container is not assigned for NPC: {gameObject.name}");
            return;
        }

        Debug.Log($"Initializing dialogue container for NPC: {gameObject.name}");
        Debug.Log($"Container has {container.DialogueGroups.Count} groups and {container.UngroupedDialogues.Count} ungrouped dialogues");

        // Cách chọn: Sử dụng DialogueManager (method 2) hoặc component riêng (method 1)
        if (useManagerBasedAdapter)
        {
            // Sử dụng manager-based adapter
            // Yêu cầu DialogueManager đã được setup ở scene
         //   dialogueAdapter = DialogueManager.Instance.GetAdapter(npcInfo.npcId, container);
        }
        else
        {
            // Sử dụng component riêng: tự thêm DSDialogueAdapter nếu chưa có
            dialogueAdapter = GetComponent<DSDialogueAdapter>();
            if (dialogueAdapter == null)
            {
                dialogueAdapter = gameObject.AddComponent<DSDialogueAdapter>();
            }
            dialogueAdapter.Initialize(container);
        }
    }

    public override void Awake()
    {
        base.Awake();
        questManager = FindAnyObjectByType<QuestManager>();

        // Tạo các map dữ liệu NPC, minigame và functional
        npcConservationMap = CreateNPCConservationMap();
        minigameDataMap = CreateMinigameDataMap();
        functionalDataMap = CreateFunctionalDataMap();

        currentDialogConservation = npcInfo.normalConservation;
    }

    public override void Interact()
    {
        base.Interact();

        if (dsDialogue == null || dsDialogue.dialogue == null)
        {
            Debug.LogWarning($"[NPCController] DSDialogue chưa được gán hoặc không có dialogue cho {gameObject.name}");
            return;
        }

        if (dialogueAdapter == null)
        {
            Debug.LogError("Dialogue adapter chưa được khởi tạo!");
            return;
        }

        // Lấy DSDialogueSO đã được thiết lập cho NPC (container)
        var dialogueSo = dsDialogue.dialogue;
        // Sử dụng adapter đã được khởi tạo để convert DSDialogueSO thành DialogConservation
        DialogConservation conv = dialogueAdapter.ConvertDSDialogueToConservation(dialogueSo);

        // Gọi ConservationManager (đã được tham chiếu trong base class TalkInteraction, thường là singleton)
        conservationManager.InitConservation(gameObject, conv);
    }

    public void OpenShopFunctionalWindow()
    {
        string functionId = FunctionType.Shop.ToString() + "_" + npcInfo.npcId;
        // Lấy functional từ map
        FunctionalWindowDataSO functionWindowData = functionalDataMap[functionId];
        functionWindowData.Init(gameObject);
    }

    #region NPC Data
    private Dictionary<string, NPCConservationSO> CreateNPCConservationMap()
    {
        // Loads all NPC conservation assets từ Resources/NPC/<npcId>
        NPCConservationSO[] allConservations = Resources.LoadAll<NPCConservationSO>("NPC/" + npcInfo.npcId);

        Dictionary<string, NPCConservationSO> map = new Dictionary<string, NPCConservationSO>();
        foreach (NPCConservationSO npcConservation in allConservations)
        {
            if (map.ContainsKey(npcConservation.conservationId))
            {
                Debug.LogWarning("Duplicate ID found when creating npc conservation map: " + npcConservation.conservationId);
            }
            else
            {
                map.Add(npcConservation.conservationId, npcConservation);
            }
        }
        return map;
    }

    private Dictionary<string, MinigameDataSO> CreateMinigameDataMap()
    {
        MinigameDataSO[] allMinigames = Resources.LoadAll<MinigameDataSO>("NPC/" + npcInfo.npcId);
        Dictionary<string, MinigameDataSO> map = new Dictionary<string, MinigameDataSO>();
        foreach (MinigameDataSO minigame in allMinigames)
        {
            if (map.ContainsKey(minigame.minigameId))
            {
                Debug.LogWarning("Duplicate ID found when creating minigame data map: " + minigame.minigameId);
            }
            else
            {
                map.Add(minigame.minigameId, minigame);
            }
        }
        return map;
    }

    private Dictionary<string, FunctionalWindowDataSO> CreateFunctionalDataMap()
    {
        FunctionalWindowDataSO[] allFunctionals = Resources.LoadAll<FunctionalWindowDataSO>("NPC/" + npcInfo.npcId);
        Dictionary<string, FunctionalWindowDataSO> map = new Dictionary<string, FunctionalWindowDataSO>();
        foreach (FunctionalWindowDataSO functional in allFunctionals)
        {
            if (map.ContainsKey(functional.functionId))
            {
                Debug.LogWarning("Duplicate ID found when creating functional data map: " + functional.functionId);
            }
            else
            {
                map.Add(functional.functionId, functional);
            }
        }
        return map;
    }
    #endregion

    #region Quest Minigame Handle
    public void StartQuestMinigame()
    {
        switch (questStep.missionType)
        {
            case StepMissionType.TALKING:
                break;

            case StepMissionType.MINIGAME:
                string minigameId = questId + "_" + questStep.stepId;
                // Tìm minigame trong map
                MinigameDataSO minigameData = minigameDataMap[minigameId];
                minigameData.Init(gameObject);
                break;
        }
    }

    public void OnQuestMinigameSuccess()
    {
        FinishQuestStep();
    }

    public void OnQuestMinigameFail()
    {
        StopInteract();
    }
    #endregion

    #region Quest Step Handle
    public void FinishQuestStep()
    {
        StopInteract();
        ResetNPC();
        questManager.OnFinishQuestStep(questId);
    }

    public void FinishQuestStepThenStartMinigame()
    {
        FinishQuestStep();
        StartQuestMinigame();
    }

    public void ResetNPC()
    {
        ChangeNPCState(NPCState.NORMAL);
        UpdateConservation();
    }

    public void UpdateQuestStep(QuestStep step, string questId)
    {
        this.questId = questId;
        questStep = step;
        ChangeNPCState(step.npcStatus);
        UpdateConservation();
    }

    public void UpdateConservation()
    {
        if (currentNPCState == NPCState.NORMAL)
        {
            currentDialogConservation = npcConservationMap[currentNPCState.ToString()];
        }
        else
        {
            string questStepConservationId = GetQuestStepConservationId();
            currentDialogConservation = npcConservationMap[questStepConservationId];
        }
    }

    public string GetQuestStepConservationId()
    {
        return currentNPCState
                + (questId != "" ? ("_" + questId) : "")
                + (questStep.stepId != "" ? ("_" + questStep.stepId) : "");
    }

    public void ChangeNPCState(NPCState state)
    {
        currentNPCState = state;
        HideAllStateIcon();
        switch (currentNPCState)
        {
            case NPCState.NORMAL:
                if (iconDefault != null)
                    iconDefault.SetActive(true);
                break;
            case NPCState.HAVE_QUEST:
                iconQuestAvailable.SetActive(true);
                break;
            case NPCState.IN_PROGRESS:
                iconQuestInProgress.SetActive(true);
                break;
            case NPCState.QUEST_COMPLETE:
                iconQuestComplete.SetActive(true);
                break;
            case NPCState.COUNTDOWN:
                break;
        }
    }

    private void HideAllStateIcon()
    {
        if (iconQuestAvailable) iconQuestAvailable.SetActive(false);
        if (iconQuestComplete) iconQuestComplete.SetActive(false);
        if (iconQuestInProgress) iconQuestInProgress.SetActive(false);
    }
    #endregion
}
</file>

<file path="InteractableObject/NPC/NPCController.cs.meta">
fileFormatVersion: 2
guid: 58317a3b9d5b7e148bc4bf7859e1f0d0
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="InteractableObject/NPC/TalkInteraction.cs">
using Core;
using Interaction;
using PlayerController;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;


#region TalkInteraction được sử dụng để làm gì
/*--------------------------------------------------------------------------------------------------------------------------------------------*/

/* TalkInteraction được thiết kế để làm cho NPC quay mặt về phía người chơi khi trò chuyện và trở lại hướng ban đầu khi hoàn thành. */

/*--------------------------------------------------------------------------------------------------------------------------------------------*/

#endregion

public class TalkInteraction : Interactable
{
    public static TalkInteraction instance;
    float rotationSpeed = 5f;
    PlayerManager playerManager;
    [HideInInspector]public ConservationManager conservationManager;
    Quaternion originalRotation;

    public virtual void Awake()
    {
        gameObject.layer = LayerMask.NameToLayer("TalkableObject");
        gameObject.tag = "Talkable";
        interactableText = "Press E to talk to NPC";

        originalRotation = transform.rotation;
        playerManager = FindObjectOfType<PlayerManager>();
        conservationManager = FindObjectOfType<ConservationManager>();
    }

    #region Phương thức Updated()

    #region Quaternion.LookRotation là gì

    /*--------------------------------------------------------------------------------------------------------------------------------------------*/

    /* Quaternion.LookRotation() là một hàm trong Unity dùng để tạo ra một rotation (quaternion) sao cho một đối tượng sẽ "nhìn về hướng chỉ định". */

    /* 💡 Dễ hiểu hơn: nó giúp bạn xoay một GameObject để hướng về phía một hướng cụ thể (thường là một Vector3 direction). */

    /*--------------------------------------------------------------------------------------------------------------------------------------------*/

    #endregion

    #region playerManager.transform.position - transform.position có ý nghĩa gì

    /*--------------------------------------------------------------------------------------------------------------------------------------------*/

    /* Đây là phép trừ giữa hai vector vị trí trong không gian 3D. Kết quả là một vector hướng đi từ NPC (transform) tới chủ thể (target).

        - target.position: vị trí của chủ thể (ví dụ, người chơi).

        - transform.position: vị trí hiện tại của NPC.

        - target.position - transform.position: vector chỉ từ NPC đến chủ thể.

      Ví dụ đơn giản:

        - Nếu target.position = (5, 0, 0)

        - Và transform.position = (2, 0, 0)

        - Thì target.position - transform.position = (3, 0, 0)

     → Vector này trỏ từ NPC tới chủ thể.

     Tổng thể:

       👉 NPC là A, chủ thể là B.

           - B - A → hướng từ A đến B → NPC quay về phía B.

           - A - B → hướng từ B đến A → NPC quay ngược (lưng quay về B).


    /*--------------------------------------------------------------------------------------------------------------------------------------------*/

    #endregion

    #endregion

    public virtual void Update()
    {
        if (isInteracting)
        {
            Quaternion tr = Quaternion.LookRotation(playerManager.transform.position - transform.position);
            HandleRotation(tr);
        }
        else
        {
            HandleRotation(originalRotation);
        }
    }

    public override void Interact()
    {
        base.Interact();
        isInteracting = true;
        //start conservation
        StartCoroutine(StartConservation());
    }

    public override void StopInteract()
    {
        base.StopInteract();
        isInteracting = false;
        //Stop conservation
        StartCoroutine(StopConservation());
    }


    #region Giải thích phương thức HandleRotation()
    /*--------------------------------------------------------------------------------------------------------------------------------------------*/

    /* Phương thức HandleRotation() nhận một parameter là một quaternion và thực hiện việc xoay NPC một cách mượt mà:

        Kiểm tra cần xoay không:

         - Quaternion.Angle(quaternion, transform.rotation) tính góc (bằng độ) giữa góc xoay hiện tại của NPC và góc xoay đích.

         - Nếu góc này > 0.01 độ, nghĩa là NPC cần xoay để đạt được hướng đích.

                  ----------------------------------------------------------------------------------------------

        Xoay mượt mà:

         - Quaternion.Slerp() (Spherical Linear Interpolation - nội suy tuyến tính cầu) là hàm quan trọng tạo ra sự chuyển động mượt mà khi xoay.

         - Nó nhận ba tham số:

           + Xoay hiện tại (transform.rotation)

           + Xoay đích (tr)

           + Hệ số nội suy (rs * Time.deltaTime)

         - rs * Time.deltaTime đảm bảo việc xoay diễn ra với tốc độ đồng nhất bất kể tốc độ khung hình (frame rate) là bao nhiêu.

         - Hàm này trả về một quaternion nằm "giữa" góc xoay hiện tại và góc xoay đích, tạo ra chuyển động mượt mà theo thời gian.

                   ----------------------------------------------------------------------------------------------

       Hoàn thành xoay:

         - Nếu góc giữa hiện tại và đích rất nhỏ (≤ 0.01 độ), NPC đã gần như đạt đến hướng mục tiêu nên nó gán trực tiếp góc xoay đích.

    /*--------------------------------------------------------------------------------------------------------------------------------------------*/

    #endregion

    void HandleRotation(Quaternion quaternion)
    {
        if(Quaternion.Angle(quaternion, transform.rotation) > 0.01f)
        {
            float rs = rotationSpeed;
            Quaternion tr = quaternion;
            Quaternion targetRotation = Quaternion.Slerp(transform.rotation, tr, rs * Time.deltaTime);
            transform.rotation = targetRotation;
        } else
        {
            transform.rotation = quaternion;
        }
    }


    #region Các Coroutine
    /*--------------------------------------------------------------------------------------------------------------------------------------------*/

    /* StartConservation():

        - Vô hiệu hóa điều khiển người chơi thông qua playerManager.DeactivateController().

        - Chờ 0.5 giây để tạo độ trễ.

        - Kích hoạt hộp thoại thông qua conservationManager.ActivateConservationDialog().

                  ----------------------------------------------------------------------------------------------

        StopConservation():

         - Vô hiệu hóa hộp thoại thông qua conservationManager.DeactivateConservationDialog().

         - Chờ 0.7 giây để tạo độ trễ.

         - Kích hoạt lại điều khiển người chơi thông qua playerManager.ActivateController().

                   ----------------------------------------------------------------------------------------------

       Coroutine cho phép các hành động xảy ra theo tuần tự với các khoảng thời gian chờ đợi mà không làm đóng băng game.

    /*--------------------------------------------------------------------------------------------------------------------------------------------*/

    #endregion

    IEnumerator StartConservation()
    {
        playerManager.DeactivateController();
        yield return new WaitForSeconds(0.5f);
        yield return conservationManager.ActivateConservationDialog();
    }

    IEnumerator StopConservation()
    {
        yield return conservationManager.DeactivateConservationDialog();
        yield return new WaitForSeconds(0.7f);
        playerManager.ActivateController();

    }
}
</file>

<file path="InteractableObject/NPC/TalkInteraction.cs.meta">
fileFormatVersion: 2
guid: cb5eeeb4e217e4e43880a4e9f6f5efa8
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="PlayerManager.meta">
fileFormatVersion: 2
guid: 73577f35e1aada141a1f2cd40bd269e9
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="PlayerManager/InputController.meta">
fileFormatVersion: 2
guid: 62b973490218f724e92cdcda3438aa66
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="PlayerManager/InputController/InputHandle.cs">
using GameManager;
using PlayerStatsController;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace PlayerController
{
    public class InputHandle : MonoBehaviour
    {
        public float horizontal;
        public float vertical;
        public float moveAmount;
        public float mouseX;
        public float mouseY;

        public bool sprint_input;
        public bool roll_input;
        public bool jump_input;
        public bool inventory_input;
        public bool pick_up;
        public bool talk_input;
        public bool lock_on_input;

        public bool rollFlag;
        public bool lockOnFlag;
        public bool sprintFlag;
        public float sprintInputTimer;
        

        PlayerControls inputActions;
        CameraHandle cameraHandle;
        UIManager uiManager;
        PlayerManager playerManager;
        PlayerStats playerStats;
        PlayerAnimatorHandle animatorHandle;

        Vector2 movementInput;
        Vector2 cameraInput;

        public Transform criticalAttackRayCastStartPoint;

        private void Start()
        {
            uiManager = FindObjectOfType<UIManager>();
            playerManager = GetComponent<PlayerManager>();
            cameraHandle = FindObjectOfType<CameraHandle>();
            animatorHandle = GetComponentInChildren<PlayerAnimatorHandle>();
            playerStats = GetComponent<PlayerStats>();
        }

        public void OnEnable()
        {
            if(inputActions == null)
            {
                inputActions = new PlayerControls();
                //bind input values to parameters
                inputActions.PlayerMovement.Movement.performed += inputActions => movementInput = inputActions.ReadValue<Vector2>();
                inputActions.PlayerMovement.Camera.performed += i => cameraInput = i.ReadValue<Vector2>();

                inputActions.PlayerAction.PickUp.performed += i => pick_up = true;
                inputActions.PlayerAction.Talk.performed += i => talk_input = true;
                inputActions.PlayerAction.Jump.performed += i => jump_input = true;
                inputActions.PlayerAction.Inventory.performed += i => inventory_input = true;

                inputActions.PlayerAction.Roll.performed += i => roll_input = true;
                inputActions.PlayerAction.Roll.canceled += i => roll_input = false;

                inputActions.PlayerAction.Sprint.performed += i => sprint_input = true;
                inputActions.PlayerAction.Sprint.canceled += i => sprint_input = false;
                

                inputActions.PlayerAction.LockOn.performed += i => lock_on_input = true;

            }
            inputActions.Enable();
        }

        public void OnDisable()
        {
            inputActions.Disable();
        }

        public void TickInput(float delta)
        {
            HandleMoveInput(delta);
            HandleRollInput(delta);
            HandleLockOnInput();
        }

        public bool isMoveInputsPressed()
        {
            if(movementInput != Vector2.zero || jump_input || roll_input)
                return true;
          
            return false;  
        }

        private void HandleMoveInput(float delta)
        {
            horizontal = movementInput.x;
            vertical = movementInput.y;
            moveAmount = Mathf.Clamp01(Mathf.Abs(horizontal) + Mathf.Abs(vertical));
            mouseX = cameraInput.x;
            mouseY = cameraInput.y;

        }

        private void HandleRollInput(float delta)
        {
            rollFlag = roll_input;

            if (sprint_input)
            {
                if (playerStats.currentStamina <= 0)
                {
                    sprint_input = false;
                    sprintFlag = false;
                }

                if (moveAmount > 0.5f && playerStats.currentStamina > 0)
                {
                    sprintFlag = true;
                }
            } else
            {
                sprintFlag = false;
            }
        }

        private void HandleLockOnInput()
        {
            if(lock_on_input && lockOnFlag == false)
            {
                lock_on_input = false;
                cameraHandle.HandleLockOn();

                if(cameraHandle.nearestLockOnTarget != null)
                {
                    cameraHandle.currentLockOnTarget = cameraHandle.nearestLockOnTarget;
                    lockOnFlag = true;
                }

            } else if(lock_on_input && lockOnFlag)
            {
                lock_on_input = false;
                lockOnFlag = false;
                //Clear lock on target
                cameraHandle.ClearLockOnTarget();
            }

            cameraHandle.SetCameraHeight();
        }

    }
}
</file>

<file path="PlayerManager/InputController/InputHandle.cs.meta">
fileFormatVersion: 2
guid: 3c101153a47d23945a53b61d3094adce
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="PlayerManager/InputController/MouseManager.cs">
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class MouseManager : MonoBehaviour
{
    void Awake()
    {
        // Ẩn con trỏ chuột khi bắt đầu game
        Cursor.visible = false;
        // Khóa con trỏ chuột ở giữa màn hình
        Cursor.lockState = CursorLockMode.Locked;
    }

    // Hàm ?? hi?n th? l?i con tr? chu?t khi c?n
    public void ShowCursor()
    {
        // Hiện con trỏ chuột
        Cursor.visible = true;
        // Mở khóa con trỏ chuột
        Cursor.lockState = CursorLockMode.None;
    }

    // Hàm ?? ?n l?i con tr? chu?t
    public void HideCursor()
    {
        // Ẩn con trỏ chuột
        Cursor.visible = false;
        // Khóa con trỏ chuột
        Cursor.lockState = CursorLockMode.Locked;
    }
}
</file>

<file path="PlayerManager/InputController/MouseManager.cs.meta">
fileFormatVersion: 2
guid: cdb6a8edb68d7fc498cad0f83978c1ad
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="PlayerManager/InputController/PlayerControls.cs">
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was auto-generated by com.unity.inputsystem:InputActionCodeGenerator
//     version 1.7.0
//     from Assets/Script/PlayerManager/InputController/PlayerControls.inputactions
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine.InputSystem;
using UnityEngine.InputSystem.Utilities;

public partial class @PlayerControls: IInputActionCollection2, IDisposable
{
    public InputActionAsset asset { get; }
    public @PlayerControls()
    {
        asset = InputActionAsset.FromJson(@"{
    ""name"": ""PlayerControls"",
    ""maps"": [
        {
            ""name"": ""Player Movement"",
            ""id"": ""ecd1ad2f-e378-4122-86bd-a4cb724e4e05"",
            ""actions"": [
                {
                    ""name"": ""Movement"",
                    ""type"": ""PassThrough"",
                    ""id"": ""82002c1f-4f3d-4988-844b-03e042d83e8c"",
                    ""expectedControlType"": ""Vector2"",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                },
                {
                    ""name"": ""Camera"",
                    ""type"": ""PassThrough"",
                    ""id"": ""3a4cfea0-ec96-4cd1-8b69-b3f5ffac6f29"",
                    ""expectedControlType"": ""Vector2"",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                },
                {
                    ""name"": ""LockOnTargetLeft"",
                    ""type"": ""Button"",
                    ""id"": ""a082621a-bdb0-461b-a21f-35ae094671ee"",
                    ""expectedControlType"": ""Button"",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                },
                {
                    ""name"": ""LockOnTargetRight"",
                    ""type"": ""Button"",
                    ""id"": ""d124c0e7-57f3-4bcb-9be7-08c633d6286e"",
                    ""expectedControlType"": ""Button"",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                }
            ],
            ""bindings"": [
                {
                    ""name"": ""WASD"",
                    ""id"": ""bc74c04a-1efb-450b-8f8e-5ef599ac415b"",
                    ""path"": ""2DVector(mode=2)"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Movement"",
                    ""isComposite"": true,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": ""up"",
                    ""id"": ""65913f88-3742-4b68-92c4-11ad207d75bb"",
                    ""path"": ""<Keyboard>/w"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Movement"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": true
                },
                {
                    ""name"": ""down"",
                    ""id"": ""45b75c92-2218-4a01-9929-7cd696efdea4"",
                    ""path"": ""<Keyboard>/s"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Movement"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": true
                },
                {
                    ""name"": ""left"",
                    ""id"": ""e65fc3d5-759e-469c-8901-39e15017a5d4"",
                    ""path"": ""<Keyboard>/a"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Movement"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": true
                },
                {
                    ""name"": ""right"",
                    ""id"": ""2433efbf-bb2d-4606-b7fe-42f0f418446e"",
                    ""path"": ""<Keyboard>/d"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Movement"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": true
                },
                {
                    ""name"": """",
                    ""id"": ""318932c0-5f81-4730-b75b-17a188687568"",
                    ""path"": ""<Gamepad>/rightStick"",
                    ""interactions"": """",
                    ""processors"": ""StickDeadzone"",
                    ""groups"": """",
                    ""action"": ""Camera"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""520a6e64-94fe-498b-821c-1ba3a40b829f"",
                    ""path"": ""<Mouse>/delta"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Camera"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""e4a23e41-43bd-491b-b2b9-557a035fcb71"",
                    ""path"": ""<Keyboard>/3"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""LockOnTargetLeft"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""204fbf24-e7b7-4fb5-b7ef-2985b84cadb9"",
                    ""path"": ""<Keyboard>/4"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""LockOnTargetRight"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                }
            ]
        },
        {
            ""name"": ""Player Action"",
            ""id"": ""6cb5125f-2452-4e53-a22a-cebe84539f37"",
            ""actions"": [
                {
                    ""name"": ""Roll"",
                    ""type"": ""Button"",
                    ""id"": ""f8018299-d8de-4742-9618-f33c3f744a62"",
                    ""expectedControlType"": ""Button"",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                },
                {
                    ""name"": ""Light Attack"",
                    ""type"": ""Button"",
                    ""id"": ""96786c5a-debf-4876-b796-041a0107633a"",
                    ""expectedControlType"": ""Button"",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                },
                {
                    ""name"": ""Critical Attack"",
                    ""type"": ""Button"",
                    ""id"": ""7388644d-84d3-4505-8a3a-3c4beac559c8"",
                    ""expectedControlType"": ""Button"",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                },
                {
                    ""name"": ""Heavy Attack"",
                    ""type"": ""Button"",
                    ""id"": ""168dc437-3fc5-42bd-ae90-31cfac6466ec"",
                    ""expectedControlType"": ""Button"",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                },
                {
                    ""name"": ""Pick Up"",
                    ""type"": ""Button"",
                    ""id"": ""6417da37-f4c9-4a19-a111-89bc539d7b88"",
                    ""expectedControlType"": ""Button"",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                },
                {
                    ""name"": ""Talk"",
                    ""type"": ""Button"",
                    ""id"": ""c176e1ea-eb87-464e-b404-b549280107c9"",
                    ""expectedControlType"": ""Button"",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                },
                {
                    ""name"": ""Jump"",
                    ""type"": ""Button"",
                    ""id"": ""433eb67d-a3ac-40c0-98c5-f1d1cde04291"",
                    ""expectedControlType"": ""Button"",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                },
                {
                    ""name"": ""Inventory"",
                    ""type"": ""Button"",
                    ""id"": ""c9cf44ec-bc9a-4e7a-b509-8334c0e05458"",
                    ""expectedControlType"": ""Button"",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                },
                {
                    ""name"": ""Lock On"",
                    ""type"": ""Button"",
                    ""id"": ""b820cbc2-1bda-4f7d-bc67-ade5b052d0e2"",
                    ""expectedControlType"": ""Button"",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                },
                {
                    ""name"": ""Y"",
                    ""type"": ""Button"",
                    ""id"": ""6e7c91c2-b31d-471b-bc3b-b49f87e10516"",
                    ""expectedControlType"": ""Button"",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                },
                {
                    ""name"": ""Sprint"",
                    ""type"": ""Button"",
                    ""id"": ""c7524db5-adb4-41e7-aed1-0660fb010908"",
                    ""expectedControlType"": ""Button"",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                }
            ],
            ""bindings"": [
                {
                    ""name"": """",
                    ""id"": ""9850e68d-8686-4d8d-af44-41563fd2600a"",
                    ""path"": ""<Mouse>/rightButton"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Roll"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""364916a7-ba1c-48ed-9151-1e7ac670b24e"",
                    ""path"": ""<Keyboard>/e"",
                    ""interactions"": ""Tap"",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Light Attack"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""49bb8542-157b-4a71-bbf8-3f2473aaf23d"",
                    ""path"": ""<Keyboard>/q"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Heavy Attack"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""a22a95c1-9ac3-4af8-a76a-e3c8c717353b"",
                    ""path"": ""<Keyboard>/f"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Pick Up"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""f8ea5d8c-ffd0-4735-adb4-e8495ef4d2ae"",
                    ""path"": ""<Keyboard>/space"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Jump"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""282ac950-93ec-4a52-b262-38edf1aa21e1"",
                    ""path"": ""<Gamepad>/start"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Inventory"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""2b2260a2-e947-4f65-9aa2-331c3901b7f4"",
                    ""path"": ""<Keyboard>/escape"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Inventory"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""3e04d639-c3bd-42e2-9cea-2ab331e8b01b"",
                    ""path"": ""<Keyboard>/leftCtrl"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Lock On"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""dd2cfadc-3a90-4e58-9389-90da68fbbf65"",
                    ""path"": ""<Keyboard>/y"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Y"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""0ccc88c9-2f43-4c27-b622-c2ab5bf26ecb"",
                    ""path"": ""<Keyboard>/e"",
                    ""interactions"": ""Hold(duration=0.2)"",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Critical Attack"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""2b5d0284-d689-4945-bd47-f9cb9151465b"",
                    ""path"": ""<Keyboard>/e"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Talk"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""7edcdce7-9f57-442f-99be-d4b971f49da2"",
                    ""path"": ""<Keyboard>/shift"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Sprint"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""04602b5e-914f-48fd-afb4-42f3af7da7cf"",
                    ""path"": ""<Gamepad>/buttonWest"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Sprint"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                }
            ]
        },
        {
            ""name"": ""Player Quick Slot"",
            ""id"": ""14983a62-01a4-4a58-825e-7b4e41b0ca4a"",
            ""actions"": [
                {
                    ""name"": ""SlotHandLeft"",
                    ""type"": ""Button"",
                    ""id"": ""1f06e8cf-3316-4c76-a3a3-5fd2427997d6"",
                    ""expectedControlType"": ""Button"",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                },
                {
                    ""name"": ""SlotHandRight"",
                    ""type"": ""Button"",
                    ""id"": ""496ac25c-2e8a-4cf7-a155-c82ec3d49f5d"",
                    ""expectedControlType"": ""Button"",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                },
                {
                    ""name"": ""D-Pad Left"",
                    ""type"": ""Button"",
                    ""id"": ""7251ba9e-876a-4c8e-a5ff-b90373fccf6f"",
                    ""expectedControlType"": ""Button"",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                },
                {
                    ""name"": ""D-Pad Right"",
                    ""type"": ""Button"",
                    ""id"": ""ff9783cc-80b8-427e-9392-9a930713507e"",
                    ""expectedControlType"": ""Button"",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                }
            ],
            ""bindings"": [
                {
                    ""name"": """",
                    ""id"": ""9488a773-a2af-49bd-9761-da11e1966feb"",
                    ""path"": ""<Keyboard>/1"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""SlotHandLeft"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""3e1e8b49-d15d-4a5c-bb36-80a3441882ef"",
                    ""path"": ""<Keyboard>/2"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""SlotHandRight"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""64cea99a-c947-45a1-ac25-e624d3ba5e99"",
                    ""path"": ""<Keyboard>/3"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""D-Pad Left"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""f7fc6df7-307c-402b-8e35-7832115e9ab5"",
                    ""path"": ""<Keyboard>/4"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""D-Pad Right"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                }
            ]
        }
    ],
    ""controlSchemes"": []
}");
        // Player Movement
        m_PlayerMovement = asset.FindActionMap("Player Movement", throwIfNotFound: true);
        m_PlayerMovement_Movement = m_PlayerMovement.FindAction("Movement", throwIfNotFound: true);
        m_PlayerMovement_Camera = m_PlayerMovement.FindAction("Camera", throwIfNotFound: true);
        m_PlayerMovement_LockOnTargetLeft = m_PlayerMovement.FindAction("LockOnTargetLeft", throwIfNotFound: true);
        m_PlayerMovement_LockOnTargetRight = m_PlayerMovement.FindAction("LockOnTargetRight", throwIfNotFound: true);
        // Player Action
        m_PlayerAction = asset.FindActionMap("Player Action", throwIfNotFound: true);
        m_PlayerAction_Roll = m_PlayerAction.FindAction("Roll", throwIfNotFound: true);
        m_PlayerAction_LightAttack = m_PlayerAction.FindAction("Light Attack", throwIfNotFound: true);
        m_PlayerAction_CriticalAttack = m_PlayerAction.FindAction("Critical Attack", throwIfNotFound: true);
        m_PlayerAction_HeavyAttack = m_PlayerAction.FindAction("Heavy Attack", throwIfNotFound: true);
        m_PlayerAction_PickUp = m_PlayerAction.FindAction("Pick Up", throwIfNotFound: true);
        m_PlayerAction_Talk = m_PlayerAction.FindAction("Talk", throwIfNotFound: true);
        m_PlayerAction_Jump = m_PlayerAction.FindAction("Jump", throwIfNotFound: true);
        m_PlayerAction_Inventory = m_PlayerAction.FindAction("Inventory", throwIfNotFound: true);
        m_PlayerAction_LockOn = m_PlayerAction.FindAction("Lock On", throwIfNotFound: true);
        m_PlayerAction_Y = m_PlayerAction.FindAction("Y", throwIfNotFound: true);
        m_PlayerAction_Sprint = m_PlayerAction.FindAction("Sprint", throwIfNotFound: true);
        // Player Quick Slot
        m_PlayerQuickSlot = asset.FindActionMap("Player Quick Slot", throwIfNotFound: true);
        m_PlayerQuickSlot_SlotHandLeft = m_PlayerQuickSlot.FindAction("SlotHandLeft", throwIfNotFound: true);
        m_PlayerQuickSlot_SlotHandRight = m_PlayerQuickSlot.FindAction("SlotHandRight", throwIfNotFound: true);
        m_PlayerQuickSlot_DPadLeft = m_PlayerQuickSlot.FindAction("D-Pad Left", throwIfNotFound: true);
        m_PlayerQuickSlot_DPadRight = m_PlayerQuickSlot.FindAction("D-Pad Right", throwIfNotFound: true);
    }

    public void Dispose()
    {
        UnityEngine.Object.Destroy(asset);
    }

    public InputBinding? bindingMask
    {
        get => asset.bindingMask;
        set => asset.bindingMask = value;
    }

    public ReadOnlyArray<InputDevice>? devices
    {
        get => asset.devices;
        set => asset.devices = value;
    }

    public ReadOnlyArray<InputControlScheme> controlSchemes => asset.controlSchemes;

    public bool Contains(InputAction action)
    {
        return asset.Contains(action);
    }

    public IEnumerator<InputAction> GetEnumerator()
    {
        return asset.GetEnumerator();
    }

    IEnumerator IEnumerable.GetEnumerator()
    {
        return GetEnumerator();
    }

    public void Enable()
    {
        asset.Enable();
    }

    public void Disable()
    {
        asset.Disable();
    }

    public IEnumerable<InputBinding> bindings => asset.bindings;

    public InputAction FindAction(string actionNameOrId, bool throwIfNotFound = false)
    {
        return asset.FindAction(actionNameOrId, throwIfNotFound);
    }

    public int FindBinding(InputBinding bindingMask, out InputAction action)
    {
        return asset.FindBinding(bindingMask, out action);
    }

    // Player Movement
    private readonly InputActionMap m_PlayerMovement;
    private List<IPlayerMovementActions> m_PlayerMovementActionsCallbackInterfaces = new List<IPlayerMovementActions>();
    private readonly InputAction m_PlayerMovement_Movement;
    private readonly InputAction m_PlayerMovement_Camera;
    private readonly InputAction m_PlayerMovement_LockOnTargetLeft;
    private readonly InputAction m_PlayerMovement_LockOnTargetRight;
    public struct PlayerMovementActions
    {
        private @PlayerControls m_Wrapper;
        public PlayerMovementActions(@PlayerControls wrapper) { m_Wrapper = wrapper; }
        public InputAction @Movement => m_Wrapper.m_PlayerMovement_Movement;
        public InputAction @Camera => m_Wrapper.m_PlayerMovement_Camera;
        public InputAction @LockOnTargetLeft => m_Wrapper.m_PlayerMovement_LockOnTargetLeft;
        public InputAction @LockOnTargetRight => m_Wrapper.m_PlayerMovement_LockOnTargetRight;
        public InputActionMap Get() { return m_Wrapper.m_PlayerMovement; }
        public void Enable() { Get().Enable(); }
        public void Disable() { Get().Disable(); }
        public bool enabled => Get().enabled;
        public static implicit operator InputActionMap(PlayerMovementActions set) { return set.Get(); }
        public void AddCallbacks(IPlayerMovementActions instance)
        {
            if (instance == null || m_Wrapper.m_PlayerMovementActionsCallbackInterfaces.Contains(instance)) return;
            m_Wrapper.m_PlayerMovementActionsCallbackInterfaces.Add(instance);
            @Movement.started += instance.OnMovement;
            @Movement.performed += instance.OnMovement;
            @Movement.canceled += instance.OnMovement;
            @Camera.started += instance.OnCamera;
            @Camera.performed += instance.OnCamera;
            @Camera.canceled += instance.OnCamera;
            @LockOnTargetLeft.started += instance.OnLockOnTargetLeft;
            @LockOnTargetLeft.performed += instance.OnLockOnTargetLeft;
            @LockOnTargetLeft.canceled += instance.OnLockOnTargetLeft;
            @LockOnTargetRight.started += instance.OnLockOnTargetRight;
            @LockOnTargetRight.performed += instance.OnLockOnTargetRight;
            @LockOnTargetRight.canceled += instance.OnLockOnTargetRight;
        }

        private void UnregisterCallbacks(IPlayerMovementActions instance)
        {
            @Movement.started -= instance.OnMovement;
            @Movement.performed -= instance.OnMovement;
            @Movement.canceled -= instance.OnMovement;
            @Camera.started -= instance.OnCamera;
            @Camera.performed -= instance.OnCamera;
            @Camera.canceled -= instance.OnCamera;
            @LockOnTargetLeft.started -= instance.OnLockOnTargetLeft;
            @LockOnTargetLeft.performed -= instance.OnLockOnTargetLeft;
            @LockOnTargetLeft.canceled -= instance.OnLockOnTargetLeft;
            @LockOnTargetRight.started -= instance.OnLockOnTargetRight;
            @LockOnTargetRight.performed -= instance.OnLockOnTargetRight;
            @LockOnTargetRight.canceled -= instance.OnLockOnTargetRight;
        }

        public void RemoveCallbacks(IPlayerMovementActions instance)
        {
            if (m_Wrapper.m_PlayerMovementActionsCallbackInterfaces.Remove(instance))
                UnregisterCallbacks(instance);
        }

        public void SetCallbacks(IPlayerMovementActions instance)
        {
            foreach (var item in m_Wrapper.m_PlayerMovementActionsCallbackInterfaces)
                UnregisterCallbacks(item);
            m_Wrapper.m_PlayerMovementActionsCallbackInterfaces.Clear();
            AddCallbacks(instance);
        }
    }
    public PlayerMovementActions @PlayerMovement => new PlayerMovementActions(this);

    // Player Action
    private readonly InputActionMap m_PlayerAction;
    private List<IPlayerActionActions> m_PlayerActionActionsCallbackInterfaces = new List<IPlayerActionActions>();
    private readonly InputAction m_PlayerAction_Roll;
    private readonly InputAction m_PlayerAction_LightAttack;
    private readonly InputAction m_PlayerAction_CriticalAttack;
    private readonly InputAction m_PlayerAction_HeavyAttack;
    private readonly InputAction m_PlayerAction_PickUp;
    private readonly InputAction m_PlayerAction_Talk;
    private readonly InputAction m_PlayerAction_Jump;
    private readonly InputAction m_PlayerAction_Inventory;
    private readonly InputAction m_PlayerAction_LockOn;
    private readonly InputAction m_PlayerAction_Y;
    private readonly InputAction m_PlayerAction_Sprint;
    public struct PlayerActionActions
    {
        private @PlayerControls m_Wrapper;
        public PlayerActionActions(@PlayerControls wrapper) { m_Wrapper = wrapper; }
        public InputAction @Roll => m_Wrapper.m_PlayerAction_Roll;
        public InputAction @LightAttack => m_Wrapper.m_PlayerAction_LightAttack;
        public InputAction @CriticalAttack => m_Wrapper.m_PlayerAction_CriticalAttack;
        public InputAction @HeavyAttack => m_Wrapper.m_PlayerAction_HeavyAttack;
        public InputAction @PickUp => m_Wrapper.m_PlayerAction_PickUp;
        public InputAction @Talk => m_Wrapper.m_PlayerAction_Talk;
        public InputAction @Jump => m_Wrapper.m_PlayerAction_Jump;
        public InputAction @Inventory => m_Wrapper.m_PlayerAction_Inventory;
        public InputAction @LockOn => m_Wrapper.m_PlayerAction_LockOn;
        public InputAction @Y => m_Wrapper.m_PlayerAction_Y;
        public InputAction @Sprint => m_Wrapper.m_PlayerAction_Sprint;
        public InputActionMap Get() { return m_Wrapper.m_PlayerAction; }
        public void Enable() { Get().Enable(); }
        public void Disable() { Get().Disable(); }
        public bool enabled => Get().enabled;
        public static implicit operator InputActionMap(PlayerActionActions set) { return set.Get(); }
        public void AddCallbacks(IPlayerActionActions instance)
        {
            if (instance == null || m_Wrapper.m_PlayerActionActionsCallbackInterfaces.Contains(instance)) return;
            m_Wrapper.m_PlayerActionActionsCallbackInterfaces.Add(instance);
            @Roll.started += instance.OnRoll;
            @Roll.performed += instance.OnRoll;
            @Roll.canceled += instance.OnRoll;
            @LightAttack.started += instance.OnLightAttack;
            @LightAttack.performed += instance.OnLightAttack;
            @LightAttack.canceled += instance.OnLightAttack;
            @CriticalAttack.started += instance.OnCriticalAttack;
            @CriticalAttack.performed += instance.OnCriticalAttack;
            @CriticalAttack.canceled += instance.OnCriticalAttack;
            @HeavyAttack.started += instance.OnHeavyAttack;
            @HeavyAttack.performed += instance.OnHeavyAttack;
            @HeavyAttack.canceled += instance.OnHeavyAttack;
            @PickUp.started += instance.OnPickUp;
            @PickUp.performed += instance.OnPickUp;
            @PickUp.canceled += instance.OnPickUp;
            @Talk.started += instance.OnTalk;
            @Talk.performed += instance.OnTalk;
            @Talk.canceled += instance.OnTalk;
            @Jump.started += instance.OnJump;
            @Jump.performed += instance.OnJump;
            @Jump.canceled += instance.OnJump;
            @Inventory.started += instance.OnInventory;
            @Inventory.performed += instance.OnInventory;
            @Inventory.canceled += instance.OnInventory;
            @LockOn.started += instance.OnLockOn;
            @LockOn.performed += instance.OnLockOn;
            @LockOn.canceled += instance.OnLockOn;
            @Y.started += instance.OnY;
            @Y.performed += instance.OnY;
            @Y.canceled += instance.OnY;
            @Sprint.started += instance.OnSprint;
            @Sprint.performed += instance.OnSprint;
            @Sprint.canceled += instance.OnSprint;
        }

        private void UnregisterCallbacks(IPlayerActionActions instance)
        {
            @Roll.started -= instance.OnRoll;
            @Roll.performed -= instance.OnRoll;
            @Roll.canceled -= instance.OnRoll;
            @LightAttack.started -= instance.OnLightAttack;
            @LightAttack.performed -= instance.OnLightAttack;
            @LightAttack.canceled -= instance.OnLightAttack;
            @CriticalAttack.started -= instance.OnCriticalAttack;
            @CriticalAttack.performed -= instance.OnCriticalAttack;
            @CriticalAttack.canceled -= instance.OnCriticalAttack;
            @HeavyAttack.started -= instance.OnHeavyAttack;
            @HeavyAttack.performed -= instance.OnHeavyAttack;
            @HeavyAttack.canceled -= instance.OnHeavyAttack;
            @PickUp.started -= instance.OnPickUp;
            @PickUp.performed -= instance.OnPickUp;
            @PickUp.canceled -= instance.OnPickUp;
            @Talk.started -= instance.OnTalk;
            @Talk.performed -= instance.OnTalk;
            @Talk.canceled -= instance.OnTalk;
            @Jump.started -= instance.OnJump;
            @Jump.performed -= instance.OnJump;
            @Jump.canceled -= instance.OnJump;
            @Inventory.started -= instance.OnInventory;
            @Inventory.performed -= instance.OnInventory;
            @Inventory.canceled -= instance.OnInventory;
            @LockOn.started -= instance.OnLockOn;
            @LockOn.performed -= instance.OnLockOn;
            @LockOn.canceled -= instance.OnLockOn;
            @Y.started -= instance.OnY;
            @Y.performed -= instance.OnY;
            @Y.canceled -= instance.OnY;
            @Sprint.started -= instance.OnSprint;
            @Sprint.performed -= instance.OnSprint;
            @Sprint.canceled -= instance.OnSprint;
        }

        public void RemoveCallbacks(IPlayerActionActions instance)
        {
            if (m_Wrapper.m_PlayerActionActionsCallbackInterfaces.Remove(instance))
                UnregisterCallbacks(instance);
        }

        public void SetCallbacks(IPlayerActionActions instance)
        {
            foreach (var item in m_Wrapper.m_PlayerActionActionsCallbackInterfaces)
                UnregisterCallbacks(item);
            m_Wrapper.m_PlayerActionActionsCallbackInterfaces.Clear();
            AddCallbacks(instance);
        }
    }
    public PlayerActionActions @PlayerAction => new PlayerActionActions(this);

    // Player Quick Slot
    private readonly InputActionMap m_PlayerQuickSlot;
    private List<IPlayerQuickSlotActions> m_PlayerQuickSlotActionsCallbackInterfaces = new List<IPlayerQuickSlotActions>();
    private readonly InputAction m_PlayerQuickSlot_SlotHandLeft;
    private readonly InputAction m_PlayerQuickSlot_SlotHandRight;
    private readonly InputAction m_PlayerQuickSlot_DPadLeft;
    private readonly InputAction m_PlayerQuickSlot_DPadRight;
    public struct PlayerQuickSlotActions
    {
        private @PlayerControls m_Wrapper;
        public PlayerQuickSlotActions(@PlayerControls wrapper) { m_Wrapper = wrapper; }
        public InputAction @SlotHandLeft => m_Wrapper.m_PlayerQuickSlot_SlotHandLeft;
        public InputAction @SlotHandRight => m_Wrapper.m_PlayerQuickSlot_SlotHandRight;
        public InputAction @DPadLeft => m_Wrapper.m_PlayerQuickSlot_DPadLeft;
        public InputAction @DPadRight => m_Wrapper.m_PlayerQuickSlot_DPadRight;
        public InputActionMap Get() { return m_Wrapper.m_PlayerQuickSlot; }
        public void Enable() { Get().Enable(); }
        public void Disable() { Get().Disable(); }
        public bool enabled => Get().enabled;
        public static implicit operator InputActionMap(PlayerQuickSlotActions set) { return set.Get(); }
        public void AddCallbacks(IPlayerQuickSlotActions instance)
        {
            if (instance == null || m_Wrapper.m_PlayerQuickSlotActionsCallbackInterfaces.Contains(instance)) return;
            m_Wrapper.m_PlayerQuickSlotActionsCallbackInterfaces.Add(instance);
            @SlotHandLeft.started += instance.OnSlotHandLeft;
            @SlotHandLeft.performed += instance.OnSlotHandLeft;
            @SlotHandLeft.canceled += instance.OnSlotHandLeft;
            @SlotHandRight.started += instance.OnSlotHandRight;
            @SlotHandRight.performed += instance.OnSlotHandRight;
            @SlotHandRight.canceled += instance.OnSlotHandRight;
            @DPadLeft.started += instance.OnDPadLeft;
            @DPadLeft.performed += instance.OnDPadLeft;
            @DPadLeft.canceled += instance.OnDPadLeft;
            @DPadRight.started += instance.OnDPadRight;
            @DPadRight.performed += instance.OnDPadRight;
            @DPadRight.canceled += instance.OnDPadRight;
        }

        private void UnregisterCallbacks(IPlayerQuickSlotActions instance)
        {
            @SlotHandLeft.started -= instance.OnSlotHandLeft;
            @SlotHandLeft.performed -= instance.OnSlotHandLeft;
            @SlotHandLeft.canceled -= instance.OnSlotHandLeft;
            @SlotHandRight.started -= instance.OnSlotHandRight;
            @SlotHandRight.performed -= instance.OnSlotHandRight;
            @SlotHandRight.canceled -= instance.OnSlotHandRight;
            @DPadLeft.started -= instance.OnDPadLeft;
            @DPadLeft.performed -= instance.OnDPadLeft;
            @DPadLeft.canceled -= instance.OnDPadLeft;
            @DPadRight.started -= instance.OnDPadRight;
            @DPadRight.performed -= instance.OnDPadRight;
            @DPadRight.canceled -= instance.OnDPadRight;
        }

        public void RemoveCallbacks(IPlayerQuickSlotActions instance)
        {
            if (m_Wrapper.m_PlayerQuickSlotActionsCallbackInterfaces.Remove(instance))
                UnregisterCallbacks(instance);
        }

        public void SetCallbacks(IPlayerQuickSlotActions instance)
        {
            foreach (var item in m_Wrapper.m_PlayerQuickSlotActionsCallbackInterfaces)
                UnregisterCallbacks(item);
            m_Wrapper.m_PlayerQuickSlotActionsCallbackInterfaces.Clear();
            AddCallbacks(instance);
        }
    }
    public PlayerQuickSlotActions @PlayerQuickSlot => new PlayerQuickSlotActions(this);
    public interface IPlayerMovementActions
    {
        void OnMovement(InputAction.CallbackContext context);
        void OnCamera(InputAction.CallbackContext context);
        void OnLockOnTargetLeft(InputAction.CallbackContext context);
        void OnLockOnTargetRight(InputAction.CallbackContext context);
    }
    public interface IPlayerActionActions
    {
        void OnRoll(InputAction.CallbackContext context);
        void OnLightAttack(InputAction.CallbackContext context);
        void OnCriticalAttack(InputAction.CallbackContext context);
        void OnHeavyAttack(InputAction.CallbackContext context);
        void OnPickUp(InputAction.CallbackContext context);
        void OnTalk(InputAction.CallbackContext context);
        void OnJump(InputAction.CallbackContext context);
        void OnInventory(InputAction.CallbackContext context);
        void OnLockOn(InputAction.CallbackContext context);
        void OnY(InputAction.CallbackContext context);
        void OnSprint(InputAction.CallbackContext context);
    }
    public interface IPlayerQuickSlotActions
    {
        void OnSlotHandLeft(InputAction.CallbackContext context);
        void OnSlotHandRight(InputAction.CallbackContext context);
        void OnDPadLeft(InputAction.CallbackContext context);
        void OnDPadRight(InputAction.CallbackContext context);
    }
}
</file>

<file path="PlayerManager/InputController/PlayerControls.cs.meta">
fileFormatVersion: 2
guid: c5db3f6990c614746951c95907b49770
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="PlayerManager/InputController/PlayerControls.inputactions">
{
    "name": "PlayerControls",
    "maps": [
        {
            "name": "Player Movement",
            "id": "ecd1ad2f-e378-4122-86bd-a4cb724e4e05",
            "actions": [
                {
                    "name": "Movement",
                    "type": "PassThrough",
                    "id": "82002c1f-4f3d-4988-844b-03e042d83e8c",
                    "expectedControlType": "Vector2",
                    "processors": "",
                    "interactions": "",
                    "initialStateCheck": false
                },
                {
                    "name": "Camera",
                    "type": "PassThrough",
                    "id": "3a4cfea0-ec96-4cd1-8b69-b3f5ffac6f29",
                    "expectedControlType": "Vector2",
                    "processors": "",
                    "interactions": "",
                    "initialStateCheck": false
                },
                {
                    "name": "LockOnTargetLeft",
                    "type": "Button",
                    "id": "a082621a-bdb0-461b-a21f-35ae094671ee",
                    "expectedControlType": "Button",
                    "processors": "",
                    "interactions": "",
                    "initialStateCheck": false
                },
                {
                    "name": "LockOnTargetRight",
                    "type": "Button",
                    "id": "d124c0e7-57f3-4bcb-9be7-08c633d6286e",
                    "expectedControlType": "Button",
                    "processors": "",
                    "interactions": "",
                    "initialStateCheck": false
                }
            ],
            "bindings": [
                {
                    "name": "WASD",
                    "id": "bc74c04a-1efb-450b-8f8e-5ef599ac415b",
                    "path": "2DVector(mode=2)",
                    "interactions": "",
                    "processors": "",
                    "groups": "",
                    "action": "Movement",
                    "isComposite": true,
                    "isPartOfComposite": false
                },
                {
                    "name": "up",
                    "id": "65913f88-3742-4b68-92c4-11ad207d75bb",
                    "path": "<Keyboard>/w",
                    "interactions": "",
                    "processors": "",
                    "groups": "",
                    "action": "Movement",
                    "isComposite": false,
                    "isPartOfComposite": true
                },
                {
                    "name": "down",
                    "id": "45b75c92-2218-4a01-9929-7cd696efdea4",
                    "path": "<Keyboard>/s",
                    "interactions": "",
                    "processors": "",
                    "groups": "",
                    "action": "Movement",
                    "isComposite": false,
                    "isPartOfComposite": true
                },
                {
                    "name": "left",
                    "id": "e65fc3d5-759e-469c-8901-39e15017a5d4",
                    "path": "<Keyboard>/a",
                    "interactions": "",
                    "processors": "",
                    "groups": "",
                    "action": "Movement",
                    "isComposite": false,
                    "isPartOfComposite": true
                },
                {
                    "name": "right",
                    "id": "2433efbf-bb2d-4606-b7fe-42f0f418446e",
                    "path": "<Keyboard>/d",
                    "interactions": "",
                    "processors": "",
                    "groups": "",
                    "action": "Movement",
                    "isComposite": false,
                    "isPartOfComposite": true
                },
                {
                    "name": "",
                    "id": "318932c0-5f81-4730-b75b-17a188687568",
                    "path": "<Gamepad>/rightStick",
                    "interactions": "",
                    "processors": "StickDeadzone",
                    "groups": "",
                    "action": "Camera",
                    "isComposite": false,
                    "isPartOfComposite": false
                },
                {
                    "name": "",
                    "id": "520a6e64-94fe-498b-821c-1ba3a40b829f",
                    "path": "<Mouse>/delta",
                    "interactions": "",
                    "processors": "",
                    "groups": "",
                    "action": "Camera",
                    "isComposite": false,
                    "isPartOfComposite": false
                },
                {
                    "name": "",
                    "id": "e4a23e41-43bd-491b-b2b9-557a035fcb71",
                    "path": "<Keyboard>/3",
                    "interactions": "",
                    "processors": "",
                    "groups": "",
                    "action": "LockOnTargetLeft",
                    "isComposite": false,
                    "isPartOfComposite": false
                },
                {
                    "name": "",
                    "id": "204fbf24-e7b7-4fb5-b7ef-2985b84cadb9",
                    "path": "<Keyboard>/4",
                    "interactions": "",
                    "processors": "",
                    "groups": "",
                    "action": "LockOnTargetRight",
                    "isComposite": false,
                    "isPartOfComposite": false
                }
            ]
        },
        {
            "name": "Player Action",
            "id": "6cb5125f-2452-4e53-a22a-cebe84539f37",
            "actions": [
                {
                    "name": "Roll",
                    "type": "Button",
                    "id": "f8018299-d8de-4742-9618-f33c3f744a62",
                    "expectedControlType": "Button",
                    "processors": "",
                    "interactions": "",
                    "initialStateCheck": false
                },
                {
                    "name": "Light Attack",
                    "type": "Button",
                    "id": "96786c5a-debf-4876-b796-041a0107633a",
                    "expectedControlType": "Button",
                    "processors": "",
                    "interactions": "",
                    "initialStateCheck": false
                },
                {
                    "name": "Critical Attack",
                    "type": "Button",
                    "id": "7388644d-84d3-4505-8a3a-3c4beac559c8",
                    "expectedControlType": "Button",
                    "processors": "",
                    "interactions": "",
                    "initialStateCheck": false
                },
                {
                    "name": "Heavy Attack",
                    "type": "Button",
                    "id": "168dc437-3fc5-42bd-ae90-31cfac6466ec",
                    "expectedControlType": "Button",
                    "processors": "",
                    "interactions": "",
                    "initialStateCheck": false
                },
                {
                    "name": "Pick Up",
                    "type": "Button",
                    "id": "6417da37-f4c9-4a19-a111-89bc539d7b88",
                    "expectedControlType": "Button",
                    "processors": "",
                    "interactions": "",
                    "initialStateCheck": false
                },
                {
                    "name": "Talk",
                    "type": "Button",
                    "id": "c176e1ea-eb87-464e-b404-b549280107c9",
                    "expectedControlType": "Button",
                    "processors": "",
                    "interactions": "",
                    "initialStateCheck": false
                },
                {
                    "name": "Jump",
                    "type": "Button",
                    "id": "433eb67d-a3ac-40c0-98c5-f1d1cde04291",
                    "expectedControlType": "Button",
                    "processors": "",
                    "interactions": "",
                    "initialStateCheck": false
                },
                {
                    "name": "Inventory",
                    "type": "Button",
                    "id": "c9cf44ec-bc9a-4e7a-b509-8334c0e05458",
                    "expectedControlType": "Button",
                    "processors": "",
                    "interactions": "",
                    "initialStateCheck": false
                },
                {
                    "name": "Lock On",
                    "type": "Button",
                    "id": "b820cbc2-1bda-4f7d-bc67-ade5b052d0e2",
                    "expectedControlType": "Button",
                    "processors": "",
                    "interactions": "",
                    "initialStateCheck": false
                },
                {
                    "name": "Y",
                    "type": "Button",
                    "id": "6e7c91c2-b31d-471b-bc3b-b49f87e10516",
                    "expectedControlType": "Button",
                    "processors": "",
                    "interactions": "",
                    "initialStateCheck": false
                },
                {
                    "name": "Sprint",
                    "type": "Button",
                    "id": "c7524db5-adb4-41e7-aed1-0660fb010908",
                    "expectedControlType": "Button",
                    "processors": "",
                    "interactions": "",
                    "initialStateCheck": false
                }
            ],
            "bindings": [
                {
                    "name": "",
                    "id": "9850e68d-8686-4d8d-af44-41563fd2600a",
                    "path": "<Mouse>/rightButton",
                    "interactions": "",
                    "processors": "",
                    "groups": "",
                    "action": "Roll",
                    "isComposite": false,
                    "isPartOfComposite": false
                },
                {
                    "name": "",
                    "id": "364916a7-ba1c-48ed-9151-1e7ac670b24e",
                    "path": "<Keyboard>/e",
                    "interactions": "Tap",
                    "processors": "",
                    "groups": "",
                    "action": "Light Attack",
                    "isComposite": false,
                    "isPartOfComposite": false
                },
                {
                    "name": "",
                    "id": "49bb8542-157b-4a71-bbf8-3f2473aaf23d",
                    "path": "<Keyboard>/q",
                    "interactions": "",
                    "processors": "",
                    "groups": "",
                    "action": "Heavy Attack",
                    "isComposite": false,
                    "isPartOfComposite": false
                },
                {
                    "name": "",
                    "id": "a22a95c1-9ac3-4af8-a76a-e3c8c717353b",
                    "path": "<Keyboard>/f",
                    "interactions": "",
                    "processors": "",
                    "groups": "",
                    "action": "Pick Up",
                    "isComposite": false,
                    "isPartOfComposite": false
                },
                {
                    "name": "",
                    "id": "f8ea5d8c-ffd0-4735-adb4-e8495ef4d2ae",
                    "path": "<Keyboard>/space",
                    "interactions": "",
                    "processors": "",
                    "groups": "",
                    "action": "Jump",
                    "isComposite": false,
                    "isPartOfComposite": false
                },
                {
                    "name": "",
                    "id": "282ac950-93ec-4a52-b262-38edf1aa21e1",
                    "path": "<Gamepad>/start",
                    "interactions": "",
                    "processors": "",
                    "groups": "",
                    "action": "Inventory",
                    "isComposite": false,
                    "isPartOfComposite": false
                },
                {
                    "name": "",
                    "id": "2b2260a2-e947-4f65-9aa2-331c3901b7f4",
                    "path": "<Keyboard>/escape",
                    "interactions": "",
                    "processors": "",
                    "groups": "",
                    "action": "Inventory",
                    "isComposite": false,
                    "isPartOfComposite": false
                },
                {
                    "name": "",
                    "id": "3e04d639-c3bd-42e2-9cea-2ab331e8b01b",
                    "path": "<Keyboard>/leftCtrl",
                    "interactions": "",
                    "processors": "",
                    "groups": "",
                    "action": "Lock On",
                    "isComposite": false,
                    "isPartOfComposite": false
                },
                {
                    "name": "",
                    "id": "dd2cfadc-3a90-4e58-9389-90da68fbbf65",
                    "path": "<Keyboard>/y",
                    "interactions": "",
                    "processors": "",
                    "groups": "",
                    "action": "Y",
                    "isComposite": false,
                    "isPartOfComposite": false
                },
                {
                    "name": "",
                    "id": "0ccc88c9-2f43-4c27-b622-c2ab5bf26ecb",
                    "path": "<Keyboard>/e",
                    "interactions": "Hold(duration=0.2)",
                    "processors": "",
                    "groups": "",
                    "action": "Critical Attack",
                    "isComposite": false,
                    "isPartOfComposite": false
                },
                {
                    "name": "",
                    "id": "2b5d0284-d689-4945-bd47-f9cb9151465b",
                    "path": "<Keyboard>/e",
                    "interactions": "",
                    "processors": "",
                    "groups": "",
                    "action": "Talk",
                    "isComposite": false,
                    "isPartOfComposite": false
                },
                {
                    "name": "",
                    "id": "7edcdce7-9f57-442f-99be-d4b971f49da2",
                    "path": "<Keyboard>/shift",
                    "interactions": "",
                    "processors": "",
                    "groups": "",
                    "action": "Sprint",
                    "isComposite": false,
                    "isPartOfComposite": false
                },
                {
                    "name": "",
                    "id": "04602b5e-914f-48fd-afb4-42f3af7da7cf",
                    "path": "<Gamepad>/buttonWest",
                    "interactions": "",
                    "processors": "",
                    "groups": "",
                    "action": "Sprint",
                    "isComposite": false,
                    "isPartOfComposite": false
                }
            ]
        },
        {
            "name": "Player Quick Slot",
            "id": "14983a62-01a4-4a58-825e-7b4e41b0ca4a",
            "actions": [
                {
                    "name": "SlotHandLeft",
                    "type": "Button",
                    "id": "1f06e8cf-3316-4c76-a3a3-5fd2427997d6",
                    "expectedControlType": "Button",
                    "processors": "",
                    "interactions": "",
                    "initialStateCheck": false
                },
                {
                    "name": "SlotHandRight",
                    "type": "Button",
                    "id": "496ac25c-2e8a-4cf7-a155-c82ec3d49f5d",
                    "expectedControlType": "Button",
                    "processors": "",
                    "interactions": "",
                    "initialStateCheck": false
                },
                {
                    "name": "D-Pad Left",
                    "type": "Button",
                    "id": "7251ba9e-876a-4c8e-a5ff-b90373fccf6f",
                    "expectedControlType": "Button",
                    "processors": "",
                    "interactions": "",
                    "initialStateCheck": false
                },
                {
                    "name": "D-Pad Right",
                    "type": "Button",
                    "id": "ff9783cc-80b8-427e-9392-9a930713507e",
                    "expectedControlType": "Button",
                    "processors": "",
                    "interactions": "",
                    "initialStateCheck": false
                }
            ],
            "bindings": [
                {
                    "name": "",
                    "id": "9488a773-a2af-49bd-9761-da11e1966feb",
                    "path": "<Keyboard>/1",
                    "interactions": "",
                    "processors": "",
                    "groups": "",
                    "action": "SlotHandLeft",
                    "isComposite": false,
                    "isPartOfComposite": false
                },
                {
                    "name": "",
                    "id": "3e1e8b49-d15d-4a5c-bb36-80a3441882ef",
                    "path": "<Keyboard>/2",
                    "interactions": "",
                    "processors": "",
                    "groups": "",
                    "action": "SlotHandRight",
                    "isComposite": false,
                    "isPartOfComposite": false
                },
                {
                    "name": "",
                    "id": "64cea99a-c947-45a1-ac25-e624d3ba5e99",
                    "path": "<Keyboard>/3",
                    "interactions": "",
                    "processors": "",
                    "groups": "",
                    "action": "D-Pad Left",
                    "isComposite": false,
                    "isPartOfComposite": false
                },
                {
                    "name": "",
                    "id": "f7fc6df7-307c-402b-8e35-7832115e9ab5",
                    "path": "<Keyboard>/4",
                    "interactions": "",
                    "processors": "",
                    "groups": "",
                    "action": "D-Pad Right",
                    "isComposite": false,
                    "isPartOfComposite": false
                }
            ]
        }
    ],
    "controlSchemes": []
}
</file>

<file path="PlayerManager/InputController/PlayerControls.inputactions.meta">
fileFormatVersion: 2
guid: 1d21f39607474d14491fba7d7f14d3e3
ScriptedImporter:
  internalIDToNameTable: []
  externalObjects: {}
  serializedVersion: 2
  userData: 
  assetBundleName: 
  assetBundleVariant: 
  script: {fileID: 11500000, guid: 8404be70184654265930450def6a9037, type: 3}
  generateWrapperCode: 1
  wrapperCodePath: 
  wrapperClassName: 
  wrapperCodeNamespace:
</file>

<file path="PlayerManager/PlayerAnimatorHandle.cs">
using Core;
using PlayerStatsController;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace PlayerController
{
    public class PlayerAnimatorHandle : AnimatorManager
    {
        PlayerManager playerManager;
        PlayerStats playerStats;
        PlayerLocomotion playerLocomotion;
        InputHandle inputHandle;
        int vertical;
        int horizontal;

        public void Initialized()
        {
            anim = GetComponent<Animator>();
            playerLocomotion = GetComponentInParent<PlayerLocomotion>();
            inputHandle = GetComponentInParent<InputHandle>();
            playerManager = GetComponentInParent<PlayerManager>();
            playerStats = GetComponentInParent<PlayerStats>();
            vertical = Animator.StringToHash("Vertical");
            horizontal = Animator.StringToHash("Horizontal");
        }

        public void UpdateAnimatorValues(float verticalMovement, float horizontalMovement, bool isSprinting)
        {

            #region Vertical
            float v = 0;
            if(verticalMovement > 0 && verticalMovement < 0.55f)
            {
                v = 0.5f;
            } else if(verticalMovement > 0.55f)
            {
                v = 1;
            } else if(verticalMovement < 0 && verticalMovement > -0.55f)
            {
                v = -1;
            } else if(verticalMovement < -0.55f) {
                v = -1;
            } else {
                v = 0;
            }
            #endregion

            #region Horizontal
            float h = 0;
            if (horizontalMovement > 0 && horizontalMovement < 0.55f)
            {
                h = 0.5f;
            }
            else if (horizontalMovement > 0.55f)
            {
                h = 1;
            }
            else if (horizontalMovement < 0 && horizontalMovement > -0.55f)
            {
                h = -1;
            }
            else if (horizontalMovement < -0.55f)
            {
                h = -1;
            }
            else
            {
                h = 0;
            }
            #endregion

            if(isSprinting)
            {
                v = 2;
                h = horizontalMovement;
            }

            anim.SetFloat(vertical, v, 0.1f, Time.deltaTime);
            anim.SetFloat(horizontal, h, 0.1f, Time.deltaTime);
        }

        public void StartClimbing()
        {
            anim.SetBool("isOnWall", true);
            PlayTargetAnimation("StickWall", true);
            playerLocomotion.rigidbody.Sleep();
            playerLocomotion.inAirTimer = 0;
            StopJumping();
            StopDoubleJump();
        }

        public void StopClimbing()
        {
            anim.SetBool("isOnWall", false);
            playerManager.isClimbable = false;
            playerLocomotion.rigidbody.WakeUp();
        }

        public void StartJumpingFromWall()
        {
            anim.SetBool("usingAnimationMove", false);
            StopClimbing();
            StartJumping();
            playerLocomotion.ReflectMoveDirection();
        }

        public void StartJumping()
        {
            anim.SetBool("isJumping", true);
        }

        public void StopJumping()
        {
            anim.SetBool("isJumping", false);
        }

        public void CanDoubleJump()
        {
            anim.SetBool("canDoubleJump", true);
        }
        public void StopDoubleJump()
        {
            anim.SetBool("canDoubleJump", false);
        }

        public void CanRotate()
        {
            anim.SetBool("canRotate", true);
        }

        public void StopRotate()
        {
            anim.SetBool("canRotate", false);
        }

        public void EnableCombo()
        {
            anim.SetBool("canDoCombo", true);
        }

        public void DisableCombo()
        {
            anim.SetBool("canDoCombo", false);
        }

        public void EnableIsInvulnerable() 
        {
            anim.SetBool("isInvulnerable", true);
        }

        public void DisableIsInvulnerable() 
        {
            anim.SetBool("isInvulnerable", false);
        }

        public override void TakeCriticalDamageAnimationEvent()
        {
            playerStats.TakeDamageNoAnimation(playerManager.pendingCriticalDamage);
            playerManager.pendingCriticalDamage = 0;
        }

        private void OnAnimatorMove()
        {
            if (playerManager.isInteracting == false)
                return;

            if (playerManager.usingAnimationMove == false)
                return;

            float delta = Time.deltaTime;
            playerLocomotion.rigidbody.drag = 0;

            Vector3 deltaPosition = anim.deltaPosition;
            deltaPosition.y = 0;
            Vector3 velocity = deltaPosition * playerStats.speedMultiplier / delta;
            playerLocomotion.SetRigidbodyVelocity(velocity);
        }
    }
}
</file>

<file path="PlayerManager/PlayerAnimatorHandle.cs.meta">
fileFormatVersion: 2
guid: 884ed41d3b0544240b1980bccae87075
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="PlayerManager/PlayerCombat.meta">
fileFormatVersion: 2
guid: 353aa113713291e42928334d1f11f725
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="PlayerManager/PlayerCombat/DamagePlayer.cs">
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace PlayerStatsController
{
    public class DamagePlayer : MonoBehaviour
    {
        public int damage = 35;

        private void OnTriggerEnter(Collider other)
        {
            PlayerStats playerStats = other.GetComponent<PlayerStats>();

            if(playerStats != null)
            {
                playerStats.TakeDamage(damage);
            }
        }
    }
}
</file>

<file path="PlayerManager/PlayerCombat/DamagePlayer.cs.meta">
fileFormatVersion: 2
guid: cf5a1d93b46c3a941b503423ff973826
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="PlayerManager/PlayerCombat/PlayerBuff.meta">
fileFormatVersion: 2
guid: 3dc643fd42327a3458e705a492d7e61a
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="PlayerManager/PlayerCombat/PlayerBuff/BuffEffect.cs">
using PlayerController;
using PlayerStatsController;
using System;
using UnityEngine;

public enum BuffType { LockStaminaBuff, RegenHP, SpeedMultiplierBuff }

[Serializable]
public class BuffEffect
{
    public BuffType type;
    public float value;
    public bool isPermanent;
    public float effectDuration;

    public void CreateAndApplyEffect()
    {
        Type fxType = Type.GetType(type.ToString());
        if (fxType != null)
        {
            BuffEffect buff = (BuffEffect)Activator.CreateInstance(fxType);
            PlayerBuffManager.instance.RegistBuff(buff.Init(this));
        }
    }

    public BuffEffect Init(BuffEffect buff)
    {
        type = buff.type;
        value = buff.value;
        isPermanent = buff.isPermanent;
        effectDuration = buff.effectDuration;
        
        return this;
    }

    public bool isBuffDurationRunOut(float deltaTime)
    {
        effectDuration -= deltaTime;
        Debug.Log(type.ToString() + " " + effectDuration);
        if(effectDuration > 0)
        {
            return false;
        } 
        else
        {
            return true;
        }
    }

    public virtual void ApplyEffect() { }
    public virtual void RemoveEffect() { }
    public virtual void OverrideEffect(BuffEffect fx) 
    {
        //remove current fx
        RemoveEffect();
        //apply new fx
        Init(fx);
        ApplyEffect();
    }
}


public class LockStaminaBuff : BuffEffect
{
    public override void ApplyEffect()
    {
        base.ApplyEffect();
        PlayerStats.instance.isLockStamina = true;
    }

    public override void RemoveEffect()
    {
        base.RemoveEffect();
        PlayerStats.instance.isLockStamina = false;
    }
}

public class SpeedMultiplierBuff : BuffEffect
{
    public override void ApplyEffect()
    {
        base.ApplyEffect();
        PlayerStats.instance.IncreaseSpeedMultiplier(value);
    }

    public override void RemoveEffect()
    {
        base.RemoveEffect();
        PlayerStats.instance.ReduceSpeedMultiplier(value);
    }
}

public class RegenHP : BuffEffect
{
    public override void ApplyEffect()
    {
        base.ApplyEffect();
        PlayerStats.instance.HealPlayer((int)value);
    }

    
}
</file>

<file path="PlayerManager/PlayerCombat/PlayerBuff/BuffEffect.cs.meta">
fileFormatVersion: 2
guid: 59d99a91ad09bd04a901d06b9ed04110
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="PlayerManager/PlayerCombat/PlayerBuff/PlayerBuffManager.cs">
using PlayerStatsController;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class PlayerBuffManager : MonoBehaviour
{
    public static PlayerBuffManager instance;
    Dictionary<BuffType, BuffEffect> playerBuffs = new Dictionary<BuffType, BuffEffect>();

    PlayerStats playerStats;

    private void Awake()
    {
        instance = this;
    }

    private void Start()
    {
        playerStats = GetComponent<PlayerStats>();
    }

    private void FixedUpdate()
    {
        if(playerBuffs.Count > 0)
        {
            foreach(BuffEffect buff in playerBuffs.Values)
            {
                if (buff.isBuffDurationRunOut(Time.deltaTime))
                {
                    buff.RemoveEffect();
                    playerBuffs.Remove(buff.type);
                    break;
                }
            }
        }
    }

    public void RegistBuff(BuffEffect buffFx)
    {
        if(buffFx.isPermanent)
        {
            buffFx.ApplyEffect();
            return;
        }

        if(playerBuffs.ContainsKey(buffFx.type))
        {
            playerBuffs[buffFx.type].OverrideEffect(buffFx);
        } else
        {
            playerBuffs.Add(buffFx.type, buffFx);
            playerBuffs[buffFx.type].ApplyEffect();
        }
    }
}
</file>

<file path="PlayerManager/PlayerCombat/PlayerBuff/PlayerBuffManager.cs.meta">
fileFormatVersion: 2
guid: 14dc216c1c17ec94d97d1d40e8f18b2d
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="PlayerManager/PlayerInventory.meta">
fileFormatVersion: 2
guid: ae3ab93b1010e83468186c66551c7021
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="PlayerManager/PlayerInventory/PlayerInventory.cs">
using Interaction;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class PlayerInventory : MonoBehaviour
{
    public static PlayerInventory instance;

    [SerializeField]
    public List<InventoryItem> inventoryItems;

    public int gold = 0;

    [field: SerializeField]
    public int Size { get; private set; } = 10;

    public event Action<Dictionary<int, InventoryItem>> OnInventoryUpdated;

    public event Action<int, int> OnGoldChanged;

    private void Awake()
    {
        instance = this;
        
        inventoryItems = new List<InventoryItem>();
        for(int i = 0; i < Size; i ++)
        {
            inventoryItems.Add(InventoryItem.GetEmptyItem());
        }
    }

    public void AddGold(int amount)
    {
        gold += amount;
        OnGoldChanged?.Invoke(amount, gold);
    }

    public void SubtractGold(int amount)
    {
        gold -= amount;
        OnGoldChanged?.Invoke(-amount, gold);
    }

    public bool TryBuyItem(int price, ItemSO item, int quantity = 1)
    {
        int cost = price * quantity;
        if (gold >= cost)
        {
            SubtractGold(cost);
            AddItem(item, quantity);
            return true;
        } 
        else
        {
            return false;
        }
    }

    public bool TryUseItem(int slotIndex, int quantity = 1)
    {
        if(inventoryItems[slotIndex].quantity >= quantity)
        {
            inventoryItems[slotIndex].item.UseItem();
            RemoveItem(slotIndex, quantity);
            return true;
        } else
        {
            return false;
        }
    }

    public int AddItem(ItemSO item, int quantity)
    {
        if (item.isStackable == false)
        {
            for (int i = 0; i < inventoryItems.Count; i++)
            {
                while (quantity > 0 && IsInventoryFull() == false)
                {
                    quantity -= AddNonStackableItem(item, 1);

                }
                InformAboutChange();
                return quantity;
            }
        }
        quantity = AddStackableItem(item, quantity);
        InformAboutChange();
        return quantity;
    }

    private int AddNonStackableItem(ItemSO item, int quantity)
    {
        InventoryItem newItem = new InventoryItem
        {
            item = item,
            quantity = quantity
        };
        for (int i = 0; i < inventoryItems.Count; i++)
        {
            if (inventoryItems[i].IsEmpty)
            {
                inventoryItems[i] = newItem;
                return quantity;
            }
        }
        return 0;
    }

    private int AddItemToFirstFreeSlot(ItemSO item, int quantity
        /*, List<ItemParameter> itemState = null*/)
    {

        InventoryItem newItem = new InventoryItem
        {
            item = item,
            quantity = quantity,

        };

        for (int i = 0; i < inventoryItems.Count; i++)
        {
            if (inventoryItems[i].IsEmpty)
            {
                inventoryItems[i] = newItem;
                return quantity;
            }
        }
        return 0;
    }

    private bool IsInventoryFull()
        => inventoryItems.Where(item => item.IsEmpty).Any() == false;

    private int AddStackableItem(ItemSO item, int quantity)
    {
        for (int i = 0; i < inventoryItems.Count; i++)
        {
            if (inventoryItems[i].IsEmpty)
                continue;
            if (inventoryItems[i].item.itemId == item.itemId)
            {
                int amountPossibleToTake =
                    inventoryItems[i].item.maxStackSize - inventoryItems[i].quantity;

                if (quantity > amountPossibleToTake)
                {
                    inventoryItems[i] = inventoryItems[i]
                        .ChangeQuantity(inventoryItems[i].item.maxStackSize);
                    quantity -= amountPossibleToTake;
                }
                else
                {
                    inventoryItems[i] = inventoryItems[i]
                        .ChangeQuantity(inventoryItems[i].quantity + quantity);
                    InformAboutChange();
                    return 0;
                }
            }
        }
        while (quantity > 0 && IsInventoryFull() == false)
        {
            int newQuantity = Mathf.Clamp(quantity, 0, item.maxStackSize);
            quantity -= newQuantity;
            AddItemToFirstFreeSlot(item, newQuantity);
        }
        return quantity;
    }

    public void RemoveItem(int itemIndex, int amount)
    {
        if (inventoryItems.Count > itemIndex)
        {
            if (inventoryItems[itemIndex].IsEmpty)
                return;
            int reminder = inventoryItems[itemIndex].quantity - amount;
            if (reminder <= 0)
                inventoryItems[itemIndex] = InventoryItem.GetEmptyItem();
            else
                inventoryItems[itemIndex] = inventoryItems[itemIndex]
                    .ChangeQuantity(reminder);

            InformAboutChange();
        }
    }

    public void AddItem(InventoryItem item)
    {
        AddItem(item.item, item.quantity);
    }

    public Dictionary<int, InventoryItem> GetCurrentInventoryState()
    {
        Dictionary<int, InventoryItem> returnValue =
            new Dictionary<int, InventoryItem>();

        for (int i = 0; i < inventoryItems.Count; i++)
        {
            if (inventoryItems[i].IsEmpty)
                continue;
            returnValue[i] = inventoryItems[i];
        }
        return returnValue;
    }

    public InventoryItem GetItemAt(int itemIndex)
    {
        return inventoryItems[itemIndex];
    }

    public void SwapItems(int itemIndex_1, int itemIndex_2)
    {
        InventoryItem item1 = inventoryItems[itemIndex_1];
        inventoryItems[itemIndex_1] = inventoryItems[itemIndex_2];
        inventoryItems[itemIndex_2] = item1;
        InformAboutChange();
    }

    private void InformAboutChange()
    {
        OnInventoryUpdated?.Invoke(GetCurrentInventoryState());
    }
}

[Serializable]
public struct InventoryItem
{
    public int quantity;
    public ItemSO item;
  
    public bool IsEmpty => item == null;

    public InventoryItem ChangeQuantity(int newQuantity)
    {
        return new InventoryItem
        {
            item = this.item,
            quantity = newQuantity,
        };
    }

    public static InventoryItem GetEmptyItem()
        => new InventoryItem
        {
            item = null,
            quantity = 0,
        };
}
</file>

<file path="PlayerManager/PlayerInventory/PlayerInventory.cs.meta">
fileFormatVersion: 2
guid: 65d462de3123eed4ca35b0fe01d0ca97
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="PlayerManager/PlayerManager.cs">
using Core;
using GameManager;
using PlayerStatsController;
using System.Collections;
using System.Collections.Generic;
using TMPro;
using UnityEngine;

namespace PlayerController
{
    
    public class PlayerManager : CharacterManager
    {
        public static PlayerManager instance;

        InputHandle inputHandle;
        UIManager uiManager;
        MouseManager mouseManager;
        Animator anim;
        CameraHandle cameraHandle;
        PlayerAnimatorHandle animatorHandle;
        PlayerStats playerStats;
        PlayerLocomotion playerLocomotion;
        public UIAnimationController interactionPopup;
        TMP_Text interactionText;
        
        public GameObject itemPopup;

        public bool isInteracting;
        public bool usingAnimationMove;

        [Header("Player Flags")]
        public bool isSprinting;
        public bool isInAir;
        public bool isJumping;
        public bool isGrounded;
        public bool isOnWall;
        public bool canDoubleJump;
        public bool isClimbable;
        LayerMask lootableMask;
        LayerMask talkableMask;

        private void Awake()
        {
            instance = this;

            inputHandle = GetComponent<InputHandle>();
            anim = GetComponentInChildren<Animator>();
            uiManager = FindObjectOfType<UIManager>();
            mouseManager = FindObjectOfType<MouseManager>();

            cameraHandle = FindObjectOfType<CameraHandle>();
            playerLocomotion = GetComponent<PlayerLocomotion>();
            playerStats = GetComponent<PlayerStats>();
            animatorHandle = GetComponentInChildren<PlayerAnimatorHandle>();

            //get component
            interactionText = interactionPopup.gameObject.GetComponentInChildren<TMP_Text>();

            //setup raycast mask
            lootableMask = 1 << LayerMask.NameToLayer("LootableObject");
            talkableMask = 1 << LayerMask.NameToLayer("TalkableObject");
        }

        private void Update()
        {
            float delta = Time.deltaTime;
            
            //get player flag from animator
            isInteracting = anim.GetBool("isInteracting");
            usingAnimationMove = anim.GetBool("usingAnimationMove"); 
            isJumping = anim.GetBool("isJumping");
            isOnWall = anim.GetBool("isOnWall");
            canDoubleJump = anim.GetBool("canDoubleJump");
            animatorHandle.canRotate = anim.GetBool("canRotate");

            //set player flag in animator 
            anim.SetBool("isInAir", isInAir);
            anim.SetBool("isDead", playerStats.isDead);

            //capture input press event
            inputHandle.TickInput(delta);

            //disable rigidbody when not moving
            playerLocomotion.rigidbody.isKinematic = !(inputHandle.isMoveInputsPressed() || isInAir || isJumping || isOnWall || usingAnimationMove);
            
            //handle input event
            playerLocomotion.HandleJumping(delta);
            playerLocomotion.HandleRollingAndSprinting(delta);
            playerStats.RegenerateStamina();
            CheckForInteractableObject();
            //
        }

        private void FixedUpdate()
        {
            float delta = Time.deltaTime;
            playerLocomotion.HandleMovement(delta);
            playerLocomotion.HandleFalling(delta, playerLocomotion.moveDirection);
            playerLocomotion.HandleStepping(delta);
            playerLocomotion.HandleOnWall(delta);
            playerLocomotion.HandleRotation(delta);
        }

        private void LateUpdate()
        {
            inputHandle.rollFlag = false;
            inputHandle.pick_up = false;
            inputHandle.talk_input = false;
            inputHandle.jump_input = false;
            inputHandle.inventory_input = false;

            float delta = Time.deltaTime;

            if (cameraHandle != null)
            {
                cameraHandle.FollowTarget(delta);
                cameraHandle.HandleCameraRotation(delta, inputHandle.mouseX, inputHandle.mouseY);
            }

            if (isInAir)
            {
                playerLocomotion.inAirTimer += Time.deltaTime;
            }
        }

        public void ActivateController()
        {
            inputHandle.enabled = true;
            uiManager.hudWindow.Activate();
            mouseManager.HideCursor();
        }

        public void DeactivateController()
        {
            inputHandle.enabled = false;
            uiManager.hudWindow.Deactivate();
            mouseManager.ShowCursor();
        }



        #region Player Interaction

        public void CheckForInteractableObject()
        {
            RaycastHit hit;
            //sphere cast cannot detect collider in overlap sphere
            if(Physics.SphereCast(transform.position - transform.forward * 0.5f, 0.5f, transform.forward, out hit, 1f, talkableMask))
            {
                if (hit.collider.tag == "Talkable")
                {
                    Interactable interactableObject = hit.collider.GetComponent<TalkInteraction>();

                    if(interactableObject != null)
                    {
                        string interactableText = interactableObject.interactableText;
                        //
                        interactionText.text = interactableText;
                        interactionPopup.Activate();

                        if(inputHandle.talk_input)
                        {
                            interactableObject.Interact();
                            
                        }
                    }
                }
            } else
            {
                if (interactionPopup != null)
                {
                    interactionPopup.Deactivate();
                }

                if (itemPopup != null && inputHandle.pick_up)
                {
                    //itemPopup.SetActive(false);
                }

            }
        }

        public void OpenChestInteraction(Transform playerStandingPosition)
        {
            //playerLocomotion.rigidbody.velocity = Vector3.zero;
            transform.position = playerStandingPosition.position;
            //

        }
        #endregion
    }

}
</file>

<file path="PlayerManager/PlayerManager.cs.meta">
fileFormatVersion: 2
guid: cadf00dfb6896174c8eec5c7e434eb07
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="PlayerManager/PlayerMovement.meta">
fileFormatVersion: 2
guid: 4fce144b496060649a52261c099b66f8
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="PlayerManager/PlayerMovement/CameraHandle.cs">
using Core;
using System.Collections;
using System.Collections.Generic;
using TMPro;
using UnityEngine;

namespace PlayerController
{
    public class CameraHandle : MonoBehaviour
    {
        InputHandle inputHandle;
        PlayerManager playerManager;
        public Transform targetTransform;
        public Transform cameraTransform;
        public Transform cameraPivotTransform;
        private Transform myTransform;
        private Vector3 cameraTransformPosition;
        public LayerMask ignoreLayers;
        public LayerMask environmentLayer;
        private Vector3 cameraFollowVelocity = Vector3.zero;

        public static CameraHandle singleton;

        public float lookSpeed = 0.1f;
        public float followSpeed = 0.1f;
        public float pivotSpeed = 0.03f;

        private float targetPosition;
        private float defaultPosition;
        private float lookAngle;
        private float pivotAngle;
        public float minimumPivot = -35;
        public float maximumPivot = 35;
        public float rotationSpeed = 1;
        public float cameraSphereRadius = 0.2f;
        public float cameraCollisionOffset = 0.2f;
        public float minimumCollisionOffset = 0.2f;

        public float lockPivotPosition = 2.25f;
        public float unlockPivotPosition = 1.65f;

        List<CharacterManager> availableTargets = new List<CharacterManager>();
        public Transform nearestLockOnTarget;
        public Transform currentLockOnTarget;
        public Transform leftLockTarget;
        public Transform rightLockTarget;
        public float maximumLockOnDistance = 30;

#if UNITY_WEBGL && !UNITY_EDITOR
        float mouseSensitivity = 0.003f;
#else
        float mouseSensitivity = 0.01f; //editor / PC
#endif
        private void Awake()
        {
            singleton = this;
            myTransform = transform;
            defaultPosition = cameraTransform.localPosition.z;
            targetTransform = FindObjectOfType<PlayerManager>().transform;
            inputHandle = FindObjectOfType<InputHandle>();
            playerManager = FindObjectOfType<PlayerManager>();
        }

        private void Start()
        {
            environmentLayer = 1 << LayerMask.NameToLayer("Environment");
        }

        public void FollowTarget(float delta)
        {
            Vector3 targetPosition = Vector3.SmoothDamp(myTransform.position, targetTransform.position, ref cameraFollowVelocity, delta / followSpeed);
            myTransform.position = targetPosition;
            HandleCameraCollisions(delta);
        }

        public void HandleCameraRotation(float delta, float mouseXInput, float mouseYInput)
        {
            //Quaternion pivotTargetRotation = cameraPivotTransform.localRotation;
            if(inputHandle.lockOnFlag == false && currentLockOnTarget == null)
            {
                lookAngle += (mouseXInput * lookSpeed) * mouseSensitivity;
                pivotAngle -= (mouseYInput * pivotSpeed) * mouseSensitivity;

                pivotAngle = Mathf.Clamp(pivotAngle, minimumPivot, maximumPivot);

                Vector3 rotation = Vector3.zero;
                rotation.y = lookAngle;
                Quaternion targetRotation = Quaternion.Euler(rotation);
                myTransform.rotation = Quaternion.Slerp(myTransform.rotation, targetRotation, rotationSpeed * Time.deltaTime);

                rotation = Vector3.zero;
                rotation.x = pivotAngle;

                targetRotation = Quaternion.Euler(rotation);
                cameraPivotTransform.localRotation = Quaternion.Slerp(cameraPivotTransform.localRotation, targetRotation, rotationSpeed * Time.deltaTime);
            } 
            else
            {

                Vector3 direction = currentLockOnTarget.position - transform.position;
                direction.Normalize();
                direction.y = 0;

                Quaternion targetRotation = Quaternion.LookRotation(direction);
                transform.rotation = targetRotation;

                direction = currentLockOnTarget.position - cameraPivotTransform.position;
                direction.Normalize();

                targetRotation = Quaternion.LookRotation(direction);
                Vector3 eulerAngle = targetRotation.eulerAngles;
                eulerAngle.y = 0;
                //cameraPivotTransform.localEulerAngles = eulerAngle;
                cameraPivotTransform.localRotation = Quaternion.Slerp(cameraPivotTransform.localRotation, Quaternion.Euler(eulerAngle), rotationSpeed * Time.deltaTime);
            }

            
        }

        private void HandleCameraCollisions(float delta)
        {
            targetPosition = defaultPosition;
            RaycastHit hit;
            Vector3 direction = cameraTransform.position - cameraPivotTransform.position;
            direction.Normalize();

            if(Physics.SphereCast
                (cameraPivotTransform.position, cameraSphereRadius, direction, out hit, Mathf.Abs(targetPosition), ignoreLayers))
            {
                float dis = Vector3.Distance(cameraPivotTransform.position, hit.point);
                targetPosition = -(dis - cameraCollisionOffset);
            }

            if(Mathf.Abs(targetPosition) < minimumCollisionOffset)
            {
                targetPosition = -minimumCollisionOffset;
            }

            cameraTransformPosition.z = Mathf.Lerp(cameraTransform.localPosition.z, targetPosition, delta / 0.2f);
            cameraTransform.localPosition = cameraTransformPosition;
        }

        public void HandleLockOn()
        {
            float shortestDistance = Mathf.Infinity;
            float shortestDistanceFromLeftTarget = Mathf.Infinity;
            float shortestDistanceFromRightTarget = Mathf.Infinity;

            Collider[] colliders = Physics.OverlapSphere(targetTransform.position, 26);

            for(int i = 0; i < colliders.Length; i ++)
            {
                CharacterManager characterManager = colliders[i].GetComponent<CharacterManager>();

                if(characterManager != null)
                {
                    Vector3 lockTargetDirection = characterManager.transform.position - targetTransform.position;
                    float distanceFromTarget = lockTargetDirection.magnitude;
                    float viewableAngle = Vector3.Angle(lockTargetDirection, cameraTransform.forward);
                    RaycastHit hit;

                    if(characterManager.transform.root != targetTransform.transform.root 
                        && viewableAngle > -50 && viewableAngle < 50 
                        && distanceFromTarget <= maximumLockOnDistance)
                    {
                        if(Physics.Linecast(playerManager.lockOnTransform.position, characterManager.transform.position, out hit))
                        {
                            Debug.DrawLine(playerManager.lockOnTransform.position, characterManager.transform.position);

                            if(hit.transform.gameObject.layer == environmentLayer)
                            {
                                //cannot lockon
                
                            }
                            else
                            {
                                availableTargets.Add(characterManager);
                            }
                        }
                        
                    }
                }
            }

            for(int i = 0; i < availableTargets.Count; i ++)
            {
                float distanceFromTarget = Vector3.Distance(targetTransform.position, availableTargets[i].transform.position);

                if(distanceFromTarget < shortestDistance)
                {
                    shortestDistance = distanceFromTarget;
                    nearestLockOnTarget = availableTargets[i].lockOnTransform;
                }

                if(inputHandle.lockOnFlag)
                {
                    Vector3 relativeEnemyPosition = currentLockOnTarget.InverseTransformPoint(availableTargets[i].transform.position);
                    var distanceFromLeftTarget = currentLockOnTarget.transform.position.x - availableTargets[i].transform.position.x;
                    var distanceFromRightTarget = currentLockOnTarget.transform.position.x + availableTargets[i].transform.position.x;

                    if(relativeEnemyPosition.x > 0.00 && distanceFromLeftTarget < shortestDistanceFromLeftTarget)
                    {
                        shortestDistanceFromLeftTarget = distanceFromLeftTarget;
                        leftLockTarget = availableTargets[i].lockOnTransform;
                    }

                    if (relativeEnemyPosition.x < 0.00 && distanceFromRightTarget < shortestDistanceFromRightTarget)
                    {
                        shortestDistanceFromRightTarget = distanceFromRightTarget;
                        rightLockTarget = availableTargets[i].lockOnTransform;
                    }
                }
            }
        }

        public void ClearLockOnTarget()
        {
            availableTargets.Clear();
            currentLockOnTarget = null;
            nearestLockOnTarget = null;
        }

        public void SetCameraHeight()
        {
            Vector3 velocity = Vector3.zero;
            Vector3 newLockedPosition = new Vector3(0, lockPivotPosition);
            Vector3 newUnlockedPosition = new Vector3(0, unlockPivotPosition, 0);

            if(currentLockOnTarget != null)
            {
                cameraPivotTransform.transform.localPosition = Vector3.SmoothDamp(cameraPivotTransform.localPosition, newLockedPosition, ref velocity, Time.deltaTime);
            }
            else
            {
                cameraPivotTransform.transform.localPosition = Vector3.SmoothDamp(cameraPivotTransform.localPosition, newUnlockedPosition, ref velocity, Time.deltaTime);
            }
        }
    }
}
</file>

<file path="PlayerManager/PlayerMovement/CameraHandle.cs.meta">
fileFormatVersion: 2
guid: a184f31898a6b974cbdd043cf9650cf4
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="PlayerManager/PlayerMovement/PlayerLocomotion.cs">
using PlayerStatsController;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace PlayerController
{
    public class PlayerLocomotion : MonoBehaviour
    {
        CameraHandle cameraHandle;
        PlayerManager playerManager;
        PlayerStats playerStats;
        Transform cameraObject;
        InputHandle inputHandle;
        public Vector3 moveDirection;

        [HideInInspector]
        public Transform myTransform;
        [HideInInspector]
        public PlayerAnimatorHandle animatorHandle;

        public new Rigidbody rigidbody;

        public GameObject normalCamera;

        public CapsuleCollider characterCollider;
        public CapsuleCollider characterCollisionBlockerCollider;

        [Header("Ground & Air Detection Stats")]
        [SerializeField]
        float groundDetectionRayStartPoint = 0.5f;
        [SerializeField]
        float minimumDistanceNeededToBeginFall = 1f;
        [SerializeField]
        float groundDirectionRayDistance = 0.2f;
        LayerMask ignoreForGroundCheck;
        public float inAirTimer;

        [Header("Jump and Falling")]
        public float fallingVelocity = 0;
        public float gravity = 15f;
        public float stepHeight = 0.4f;
        public float jumpVelocity = 7f;
        Vector3 wallNormal;

        [Header("Stamina Costs")]
        [SerializeField]
        int rollStaminaCost = 15;
        int backStepStaminaCost = 12;
        int sprintStaminaCost = 1;

        [Header("Movement Stats")]
        [SerializeField]
        float walkingSpeed = 3;
        [SerializeField]
        float movementSpeed = 5;
        [SerializeField]
        float sprintSpeed = 7;
        [SerializeField]
        float rotationSpeed = 10;
        [SerializeField]
        float currentRunningSpeed = 0;

        private void Awake()
        {
            cameraHandle = FindObjectOfType<CameraHandle>();
            playerManager = GetComponent<PlayerManager>();
            rigidbody = GetComponent<Rigidbody>();
            inputHandle = GetComponent<InputHandle>();
            animatorHandle = GetComponentInChildren<PlayerAnimatorHandle>();
            playerStats = GetComponent<PlayerStats>();
            
        }


        void Start()
        {
            cameraObject = Camera.main.transform;
            myTransform = transform;
            animatorHandle.Initialized();

            playerManager.isGrounded = true;
            playerManager.isClimbable = true;
            ignoreForGroundCheck = ~(1 << LayerMask.NameToLayer("Player") | 1 << LayerMask.NameToLayer("CharacterColliderBlocker"));

            Physics.IgnoreCollision(characterCollider, characterCollisionBlockerCollider, true);
        }

        #region Movement
        Vector3 normalVector = Vector3.up;
        Vector3 targetPosition;

        public void HandleRotation(float delta)
        {
            if (animatorHandle.canRotate)
            {
                if (inputHandle.lockOnFlag && inputHandle.sprintFlag == false)
                {
                    if (inputHandle.sprintFlag || inputHandle.rollFlag)
                    {
                        Vector3 targetDirection = Vector3.zero;
                        targetDirection = cameraHandle.cameraTransform.forward * inputHandle.vertical;
                        targetDirection += cameraHandle.cameraTransform.right * inputHandle.horizontal;
                        targetDirection.Normalize();
                        targetDirection.y = 0;

                        if (targetDirection == Vector3.zero)
                        {
                            targetDirection = transform.forward;
                        }

                        Quaternion tr = Quaternion.LookRotation(targetDirection);
                        Quaternion targetRotation = Quaternion.Slerp(transform.rotation, tr, rotationSpeed * Time.deltaTime);

                        transform.rotation = targetRotation;
                    }
                    else
                    {
                        Vector3 rotationDirection = moveDirection;
                        rotationDirection = cameraHandle.currentLockOnTarget.position - transform.position;
                        rotationDirection.y = 0;

                        rotationDirection.Normalize();

                        Quaternion tr = Quaternion.LookRotation(rotationDirection);
                        Quaternion targetRotation = Quaternion.Slerp(transform.rotation, tr, rotationSpeed * Time.deltaTime);
                        transform.rotation = targetRotation;
                    }

                }
                else
                {
                    Vector3 targetDir = Vector3.zero;
                    float moveOverride = inputHandle.moveAmount;

                    targetDir = cameraObject.forward * inputHandle.vertical;
                    targetDir += cameraObject.right * inputHandle.horizontal;

                    targetDir.Normalize();
                    targetDir.y = 0;

                    if (targetDir == Vector3.zero)
                        targetDir = myTransform.forward;

                    float rs = rotationSpeed;

                    Quaternion tr = Quaternion.LookRotation(targetDir);
                    Quaternion targetRotation = Quaternion.Slerp(myTransform.rotation, tr, rs * delta);
                    myTransform.rotation = targetRotation;
                }
            } 

            if(playerManager.isInAir)
            {
                if(moveDirection.magnitude > 0.1f)
                {
                    float rs = rotationSpeed;
                    Quaternion tr = Quaternion.LookRotation(moveDirection.normalized);
                    Quaternion targetRotation = Quaternion.Slerp(myTransform.rotation, tr, rs * delta);
                    myTransform.rotation = targetRotation;
                }
            }

            if(playerManager.isGrounded)
            {
                float rs = rotationSpeed;
                Quaternion tr = Quaternion.Euler(0, myTransform.rotation.eulerAngles.y, 0);
                Quaternion targetRotation = Quaternion.Slerp(myTransform.rotation, tr, rs * delta);
                myTransform.rotation = targetRotation;
            }
        }

        public void HandleMovement(float delta)
        {
            if (playerManager.usingAnimationMove)
                return;

            if (inputHandle.rollFlag)
                return;

            if (playerManager.isInteracting)
                return;

            moveDirection = cameraObject.forward * inputHandle.vertical;
            moveDirection += cameraObject.right * inputHandle.horizontal;
            moveDirection.Normalize();
            moveDirection.y = 0;

            currentRunningSpeed = movementSpeed;

            if (inputHandle.sprintFlag && inputHandle.moveAmount > 0.5)
            {
                currentRunningSpeed = sprintSpeed;
                playerManager.isSprinting = true;
                playerStats.ReduceStamina(sprintStaminaCost);
            }
            else
            {
                if (inputHandle.moveAmount < 0.5f)
                {
                    currentRunningSpeed = walkingSpeed;
                }
                else
                {
                    currentRunningSpeed = movementSpeed;
                }
                playerManager.isSprinting = false;
            }

            moveDirection *= CalculateRunningSpeed(currentRunningSpeed);

            Vector3 projectedVelocity = Vector3.ProjectOnPlane(moveDirection, normalVector).normalized * CalculateRunningSpeed(currentRunningSpeed);
            SetRigidbodyVelocity(projectedVelocity);

            if (inputHandle.lockOnFlag && inputHandle.sprintFlag == false)
            {
                animatorHandle.UpdateAnimatorValues(inputHandle.vertical, inputHandle.horizontal, playerManager.isSprinting);
            }
            else
            {
                animatorHandle.UpdateAnimatorValues(inputHandle.moveAmount, 0, playerManager.isSprinting);
            }
        }

        public void HandleStepping(float delta)
        {
            if (playerManager.usingAnimationMove)
                return;

            if (inputHandle.rollFlag)
                return;

            if (playerManager.isInteracting)
                return;

            if (playerManager.isOnWall)
                return;

            if (playerManager.isInAir || playerManager.isJumping)
                return;

            if (moveDirection.magnitude == 0) return;

            RaycastHit hitLower45;
            Vector3 startTestStepPosition = transform.position;
            float maxDistance = 0.6f;

            Vector3 foward = moveDirection.normalized;
            Collider[] hitLowers = Physics.OverlapBox(startTestStepPosition, new Vector3(maxDistance, 0, maxDistance), Quaternion.identity, cameraHandle.environmentLayer); 
            
            if (hitLowers.Length > 0)
            {
                Collider[] hitUppers = Physics.OverlapBox(startTestStepPosition + new Vector3(0, stepHeight, 0), new Vector3(maxDistance, 0, maxDistance), Quaternion.identity, cameraHandle.environmentLayer);
                if (hitUppers.Length == 0)
                {
                    //fix calculate raycast with all collider
                    bool a = hitLowers[0].Raycast(new Ray(startTestStepPosition, foward), out hitLower45, 0.5f);
                    Debug.Log("stepping " + a + " " + Vector3.Dot(hitLower45.normal, transform.up));
                    bool canClimbSlope = Vector3.Dot(hitLower45.normal, transform.up) < 0.1f;
             
                    if (a && canClimbSlope)
                    {
                        Vector3 move = moveDirection.normalized + Vector3.up;
                        SetRigidbodyVelocity(CalculateRunningSpeed(currentRunningSpeed) * move.normalized);
                    }
                    
                    return;
                }
            }
        }

        public void HandleRollingAndSprinting(float delta)
        {
            if (playerManager.usingAnimationMove)
                return;

            if (playerManager.isInteracting)
                return;

            if (playerStats.currentStamina <= 0)
                return;

            

            if (inputHandle.rollFlag)
            {
                moveDirection += cameraObject.forward * inputHandle.vertical;
                moveDirection += cameraObject.right * inputHandle.horizontal;


                if (inputHandle.moveAmount > 0)
                {
                    animatorHandle.PlayTargetAnimation("Rolling", true);
                    animatorHandle.anim.SetBool("usingAnimationMove", true);
                    moveDirection.y = 0;
                    Quaternion rollRotation = Quaternion.LookRotation(moveDirection);
                    myTransform.rotation = rollRotation;

                    playerStats.ReduceStamina(rollStaminaCost);
                }
                else
                {
                    animatorHandle.PlayTargetAnimation("Backstep", true);
                    animatorHandle.anim.SetBool("usingAnimationMove", true);
                    playerStats.ReduceStamina(backStepStaminaCost);
                }
            }
        }

        public void HandleFalling(float delta, Vector3 moveDirection)
        {
            if (playerManager.usingAnimationMove)
                return;

            if (playerManager.isOnWall)
                return;

            playerManager.isGrounded = false;
            RaycastHit hit;
            Vector3 origin = myTransform.position;
            origin.y += groundDetectionRayStartPoint;

            //check wall to climb
            if(playerManager.isJumping && playerManager.isInAir && playerManager.isClimbable)
            {
                if (Physics.SphereCast(origin, groundDetectionRayStartPoint, moveDirection.normalized, out hit, 0.3f, cameraHandle.environmentLayer))
                {
                    moveDirection = Vector3.zero;
                    
                    bool climbable = (hit.collider.gameObject.layer == LayerMask.NameToLayer("Environment"));
                    float dotTest = Mathf.Abs( Vector3.Dot(hit.normal, transform.up) );

                    if (climbable && dotTest < 0.2f)
                    {
                        //start climp wall
                        Debug.Log("asd");
                        animatorHandle.StartClimbing();
                        playerManager.isClimbable = false;
                        targetPosition = hit.point + hit.normal * 0.31f;
                        wallNormal = hit.normal;
                        return;
                    }
                }
            }

            //change velocity of rigidbody
            if(moveDirection.magnitude < 0.05f) 
            { 
                moveDirection = Vector3.zero; 
            }
            Vector3 velocity = moveDirection.normalized * CalculateRunningSpeed(currentRunningSpeed) - fallingVelocity * Vector3.up;

            if (playerManager.isJumping)
            {
                //velocity += moveDirection.normalized * currentRunningSpeed;
                velocity += Vector3.up * jumpVelocity;
            }

            SetRigidbodyVelocity(velocity);

            Vector3 dir = moveDirection;
            dir.Normalize();
            origin = origin + Vector3.up * groundDirectionRayDistance;
            targetPosition = myTransform.position;

            //start falling
            if (velocity.y < 0.1f)
            {
                if (Physics.SphereCast(origin, 0.1f, -Vector3.up, out hit, minimumDistanceNeededToBeginFall, ignoreForGroundCheck))
                {
                    normalVector = hit.normal;
                    Vector3 tp = hit.point;
                    targetPosition.y = tp.y + 0.02f;
                    playerManager.isGrounded = true;

                    if (playerManager.isInAir)
                    {
                        if (inAirTimer > 0.1f)
                        {
                            Debug.Log("You were in the air for " + inAirTimer);
                            animatorHandle.PlayTargetAnimation("Land", true);
                        }
                        else
                        {
                            animatorHandle.PlayTargetAnimation("Empty", false);
                        }

                        inAirTimer = 0;
                        playerManager.isInAir = false;
                        playerManager.isClimbable = true;
                        this.moveDirection = Vector3.zero;
                        animatorHandle.StopJumping();
                        animatorHandle.StopDoubleJump();
                    }
                }
                else
                {
                    
                    if (playerManager.isGrounded)
                    {
                        playerManager.isGrounded = false;
                    }

                    if (playerManager.isInAir == false)
                    {

                        if (playerManager.isInteracting == false)
                        {
                            animatorHandle.PlayTargetAnimation("Falling", true);
                        }

                        playerManager.isInAir = true;
                    }
                }
            }


            if (playerManager.isGrounded)
            {
                if (playerManager.isInteracting || inputHandle.moveAmount > 0)
                {
                    myTransform.position = Vector3.Lerp(myTransform.position, targetPosition, Time.deltaTime / 0.1f);
                }
                else
                {
                    myTransform.position = Vector3.Lerp(myTransform.position, targetPosition, Time.deltaTime / 0.1f);
                }

                if(!playerManager.isJumping) 
                    fallingVelocity = 0;
            }
            else
            {
                fallingVelocity += gravity * Time.deltaTime;
            }

        }

        public void HandleOnWall(float delta)
        {
            if(playerManager.isOnWall)
            {
                //remove gravity
                SetRigidbodyVelocity(Vector3.zero);
                
                //move close to wall
                if(playerManager.isClimbable == false)
                {
                    if (Vector3.Distance(myTransform.position, targetPosition) < 0.02f)
                    {
                        myTransform.position = targetPosition;
                        playerManager.isClimbable = true;
                    } else
                    {
                        myTransform.position = Vector3.Lerp(myTransform.position, targetPosition, Time.deltaTime * 5f);
                    }
                    return;
                }

                //handle rotation
                RaycastHit hit;
                Debug.DrawRay(transform.position, -wallNormal);
                if (Physics.SphereCast(transform.position, 0.3f, -wallNormal, out hit, 0.6f))
                {
                    Quaternion targetRotation = Quaternion.LookRotation(-hit.normal, transform.up);
                    wallNormal = wallNormal + hit.normal;
                    wallNormal.Normalize();
                    transform.forward = -wallNormal;
                    
                    //
                    //wallNormal = hit.normal;
                }
                else
                {
                    //if(Vector3.Angle(transform.forward)
                    animatorHandle.StopClimbing();
                    return;
                }

                if (inputHandle.moveAmount > 0)
                {
                    Vector3 right = Vector3.Cross(wallNormal, transform.up);
                    Vector3 forward = Vector3.Cross(right, wallNormal);
                    Vector3 climbDirection = forward * inputHandle.vertical;
                    climbDirection += right * inputHandle.horizontal;
                    climbDirection.Normalize();

                    Vector3 projectedVelocity = Vector3.ProjectOnPlane(climbDirection, wallNormal).normalized;
                    SetRigidbodyVelocity(projectedVelocity);
                    animatorHandle.anim.SetBool("isClimbing", true);
                    inAirTimer = 0f;
                } else
                {
                    animatorHandle.anim.SetBool("isClimbing", false);
                }

                if (inAirTimer > 1.6f)
                {
                    //animatorHandle.StopClimbing();
                }
            }
        }

        public void HandleJumping(float delta)
        {
            if (playerManager.usingAnimationMove)
                return;

            if (playerManager.isInteracting && !playerManager.isOnWall && !playerManager.isInAir)
                return;

            //if (playerStats.currentStamina <= 0)
            //    return;

            if (inputHandle.jump_input)
            {
                if(playerManager.isOnWall)
                {
                    animatorHandle.PlayTargetAnimation("JumpFromWall", true);
                    animatorHandle.anim.SetBool("usingAnimationMove", true);
                 
                    fallingVelocity = 0;
                    return;
                }

                if(playerManager.canDoubleJump && playerManager.isInAir)
                {
                    animatorHandle.PlayTargetAnimation("DoubleJump", true);
                    animatorHandle.StartJumping();
                    playerManager.isClimbable = false;
                    fallingVelocity = 0;
                    return;
                }

                if (inputHandle.moveAmount > 0 && rigidbody.velocity.magnitude > 0.1f)
                {
                    //moveDirection = cameraObject.forward * inputHandle.vertical;
                    //moveDirection += cameraObject.right * inputHandle.horizontal;
                    //moveDirection.y = 0;
                    //moveDirection.Normalize();
                    animatorHandle.PlayTargetAnimation("Jump", true);
                    
                    Quaternion jumpRotation = Quaternion.LookRotation(moveDirection);
                    myTransform.rotation = jumpRotation;
                    animatorHandle.StartJumping();
                }
                else
                {
                    animatorHandle.PlayTargetAnimation("Jump", true);
                    moveDirection = transform.forward * 0.01f;
                    animatorHandle.StartJumping();
                }
            }
        }

        public void ReflectMoveDirection()
        {
            moveDirection = wallNormal * CalculateRunningSpeed(currentRunningSpeed);
            //Vector3.Reflect(moveDirection, wallNormal);
        }

        #endregion

        public float CalculateRunningSpeed(float speed)
        {
            return speed * playerStats.speedMultiplier;
        }

        public void SetRigidbodyVelocity(Vector3 velocity)
        {
            if (!rigidbody.isKinematic)
                rigidbody.velocity = velocity;
        }
    }

}
</file>

<file path="PlayerManager/PlayerMovement/PlayerLocomotion.cs.meta">
fileFormatVersion: 2
guid: 90fcd99f0b3b1fc4b8c56a9cda48e92a
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="PlayerManager/PlayerStats.meta">
fileFormatVersion: 2
guid: 8423cacbf39f5b841939073699758803
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="PlayerManager/PlayerStats/PlayerStats.cs">
using Core;
using PlayerController;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace PlayerStatsController
{
    public class PlayerStats : CharacterStats
    {
        public static PlayerStats instance;
        PlayerManager playerManager;
        HealthBar healthBar;
        StaminaBar staminaBar;
        PlayerAnimatorHandle animatorHandle;

        public float staminaRegenerationAmount = 30;
        public float regenerationStaminaTimer = 0;

        public int soulCount;
        private void Awake()
        {
            instance = this;
            healthBar = FindObjectOfType<HealthBar>();
            staminaBar = FindAnyObjectByType<StaminaBar>();
            playerManager = GetComponent<PlayerManager>();
            animatorHandle = GetComponentInChildren<PlayerAnimatorHandle>();
        }

        private void Start()
        {
            maxHealth = SetMaxHealthFromHealthLevel();
            currentHealth = maxHealth;
            healthBar.SetMaxHealth(maxHealth);
            healthBar.SetCurrentHealth(currentHealth);

            maxStamina = SetMaxStaminaFromStaminaLevel();
            currentStamina = maxStamina;
            staminaBar.SetMaxStamina(maxStamina);
            staminaBar.SetCurrentStamina(currentStamina);
        }

        private int SetMaxHealthFromHealthLevel()
        {
            maxHealth = healthLevel * 10;
            return maxHealth;
        }

        private float SetMaxStaminaFromStaminaLevel()
        {
            maxStamina = staminaLevel * 20;
            return maxStamina;
        }

        public void TakeDamageNoAnimation(int damage)
        {
            if (isDead)
                return;

            currentHealth -= damage;
            healthBar.SetCurrentHealth(currentHealth);
            if (currentHealth <= 0)
            {
                currentHealth = 0;
                isDead = true;
            }  
        }

        public void TakeDamage(int damage)
        {
            if (isDead)
                return;

            currentHealth -= damage;
            healthBar.SetCurrentHealth(currentHealth);

            if(currentHealth <= 0)
            {
                HandleDeath();
            } else
            {
                animatorHandle.PlayTargetAnimation("Damage_01", true);
            }
        }

        private void HandleDeath()
        {
            currentHealth = 0;
            animatorHandle.PlayTargetAnimation("Death_01", true);
            isDead = true;
        }

        public void IncreaseSpeedMultiplier(float amount)
        {
            speedMultiplier = speedMultiplier + amount;
        }

        public void ReduceSpeedMultiplier(float amount)
        {
            speedMultiplier -= amount;
            speedMultiplier = Mathf.Clamp(speedMultiplier, 1, float.PositiveInfinity);
        }

        public void ReduceStamina(int amount)
        {
            if (isLockStamina) return;

            regenerationStaminaTimer = 0;
            currentStamina -= amount;
            staminaBar.SetCurrentStamina((int)currentStamina);
        }

        public void RegenerateStamina()
        {
 
            if (playerManager.isInteracting)
            {
                regenerationStaminaTimer = 0;
            }
            else
            {
                regenerationStaminaTimer += Time.deltaTime;

                if (currentStamina < maxStamina && regenerationStaminaTimer > 1f)
                {
                    currentStamina += staminaRegenerationAmount * Time.deltaTime;
                    staminaBar.SetCurrentStamina((int)currentStamina);
                }
            }

        }

        public void HealPlayer(int healAmount)
        {
            currentHealth = currentHealth + healAmount;

            if(currentHealth > maxHealth)
            {
                currentHealth = maxHealth;
            }

            healthBar.SetCurrentHealth(currentHealth);
        }
    }
}
</file>

<file path="PlayerManager/PlayerStats/PlayerStats.cs.meta">
fileFormatVersion: 2
guid: baf1e40034e78b443a3b47bc93704ca1
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="PlayerManager/PlayerStats/PlayerUI.meta">
fileFormatVersion: 2
guid: 1aeb5ac12c084ab4cab5896dc9077e3f
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="PlayerManager/PlayerStats/PlayerUI/HealthBar.cs">
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;

namespace PlayerStatsController
{
    public class HealthBar : MonoBehaviour
    {
        public Slider slider;
        public Gradient gradient;
        public Image fill;

        private void Awake()
        {
            slider = GetComponent<Slider>();
        }

        public void SetMaxHealth(float maxHealth)
        {
            slider.maxValue = maxHealth;
            slider.value = maxHealth;

            fill.color = gradient.Evaluate(1f);

        }

        public void SetCurrentHealth(float currentHealth)
        {
            slider.value = currentHealth;

            fill.color = gradient.Evaluate(slider.normalizedValue);
        }


    }
}
</file>

<file path="PlayerManager/PlayerStats/PlayerUI/HealthBar.cs.meta">
fileFormatVersion: 2
guid: 8fb67361253644f43814cbb11b330529
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="PlayerManager/PlayerStats/PlayerUI/StaminaBar.cs">
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;

namespace PlayerStatsController
{
    public class StaminaBar : MonoBehaviour
    {
        public Slider slider;
        public Gradient gradient;
        public Image fill;

        private void Awake()
        {
            slider = GetComponent<Slider>();    
        }

        public void SetMaxStamina(float maxStamina)
        {
            slider.maxValue = maxStamina;
            slider.value = maxStamina;

            fill.color = gradient.Evaluate(1f);
        }

        public void SetCurrentStamina(float currentStamina)
        {
            slider.value = currentStamina;

            fill.color = gradient.Evaluate(slider.normalizedValue);
        }
    }
}
</file>

<file path="PlayerManager/PlayerStats/PlayerUI/StaminaBar.cs.meta">
fileFormatVersion: 2
guid: ede2daf8b1bbe79478d9ca474f029699
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

</files>
